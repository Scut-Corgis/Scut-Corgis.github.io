<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/corgis.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/corgis.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scut-corgis.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="内存管理set预分配元数据预分配，提前分配了4096个set元数据 1ns-&gt;p_sets_vmap  索引操作key的hash值用0号字节8位表示partition-id，用1-4号字节的28位表示属于该partition的哪一颗子树(sprig)，默认一个partition有256颗子树，每一颗子树存在一个互斥锁。 内存索引结构如下。其实除去一些保留的、功能性的、集群相关的字段，核心字段">
<meta property="og:type" content="article">
<meta property="og:title" content="aerospike学习(2)-内存管理">
<meta property="og:url" content="https://scut-corgis.github.io/2025-04-19-aerospike%E5%AD%A6%E4%B9%A0(2)-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="corgis的笔记">
<meta property="og:description" content="内存管理set预分配元数据预分配，提前分配了4096个set元数据 1ns-&gt;p_sets_vmap  索引操作key的hash值用0号字节8位表示partition-id，用1-4号字节的28位表示属于该partition的哪一颗子树(sprig)，默认一个partition有256颗子树，每一颗子树存在一个互斥锁。 内存索引结构如下。其实除去一些保留的、功能性的、集群相关的字段，核心字段">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://scut-corgis.github.io/2025-04-19-aerospike%E5%AD%A6%E4%B9%A0(2)-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/ns%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.svg">
<meta property="og:image" content="https://scut-corgis.github.io/2025-04-19-aerospike%E5%AD%A6%E4%B9%A0(2)-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%B4%A2%E5%BC%95%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png">
<meta property="article:published_time" content="2025-04-19T09:41:51.000Z">
<meta property="article:modified_time" content="2025-05-27T12:33:06.986Z">
<meta property="article:author" content="Corgis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://scut-corgis.github.io/2025-04-19-aerospike%E5%AD%A6%E4%B9%A0(2)-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/ns%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.svg">


<link rel="canonical" href="https://scut-corgis.github.io/2025-04-19-aerospike%E5%AD%A6%E4%B9%A0(2)-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://scut-corgis.github.io/2025-04-19-aerospike%E5%AD%A6%E4%B9%A0(2)-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","path":"2025-04-19-aerospike学习(2)-内存管理/","title":"aerospike学习(2)-内存管理"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>aerospike学习(2)-内存管理 | corgis的笔记</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">corgis的笔记</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#set%E9%A2%84%E5%88%86%E9%85%8D"><span class="nav-number">1.1.</span> <span class="nav-text">set预分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.</span> <span class="nav-text">索引操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E7%B4%A2%E5%BC%95%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">1.3.</span> <span class="nav-text">主索引内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wblock%E7%BC%93%E5%AD%98"><span class="nav-number">1.4.</span> <span class="nav-text">wblock缓存</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Corgis"
      src="/images/corgis.jpg">
  <p class="site-author-name" itemprop="name">Corgis</p>
  <div class="site-description" itemprop="description">用于成长过程中，记录值得对外分享的技术，如开源代码理解、国外课程项目，个人对一些领域的心得等</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://scut-corgis.github.io/2025-04-19-aerospike%E5%AD%A6%E4%B9%A0(2)-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/corgis.jpg">
      <meta itemprop="name" content="Corgis">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corgis的笔记">
      <meta itemprop="description" content="用于成长过程中，记录值得对外分享的技术，如开源代码理解、国外课程项目，个人对一些领域的心得等">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="aerospike学习(2)-内存管理 | corgis的笔记">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          aerospike学习(2)-内存管理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-19 17:41:51" itemprop="dateCreated datePublished" datetime="2025-04-19T17:41:51+08:00">2025-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%93%88%E5%B8%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">哈希存储引擎</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="set预分配"><a href="#set预分配" class="headerlink" title="set预分配"></a>set预分配</h2><p>元数据预分配，提前分配了4096个set元数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ns-&gt;p_sets_vmap</span><br></pre></td></tr></table></figure>
<p><img src="/2025-04-19-aerospike%E5%AD%A6%E4%B9%A0(2)-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/ns%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.svg"></p>
<h2 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h2><p>key的hash值用0号字节8位表示partition-id，用1-4号字节的28位表示属于该partition的哪一颗子树(sprig)，默认一个partition有256颗子树，每一颗子树存在一个互斥锁。</p>
<p>内存索引结构如下。其实除去一些保留的、功能性的、集群相关的字段，核心字段的有效字节数约为42字节。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">as_index_s</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset: 0</span></span><br><span class="line">    <span class="comment">/* 该rc 用于红黑树遍历时(比如节点增加，使得某些index迁移插入到另一棵树)，防止该索引被释放。</span></span><br><span class="line"><span class="comment">        为了减少锁冲突，每一颗有两种锁，reduce锁专门为该场景涉及，在reduce锁期间只收集节点指针，不做复杂操作。 */</span></span><br><span class="line">    <span class="type">uint16_t</span> rc; <span class="comment">// for now, incremented &amp; decremented only when reducing sprig</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset: 2</span></span><br><span class="line">    <span class="type">uint8_t</span> : <span class="number">8</span>; <span class="comment">// reserved for bigger rc, if needed</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset: 3</span></span><br><span class="line">    <span class="type">uint8_t</span> tree_id: <span class="number">6</span>;	<span class="comment">// partition对应的tree_id，ssd开头的header中有记录（一个ns可能有多颗树，比如二级索引也有树）</span></span><br><span class="line">    <span class="type">uint8_t</span> color: <span class="number">1</span>;	<span class="comment">//红或黑</span></span><br><span class="line">    <span class="type">uint8_t</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset: 4</span></span><br><span class="line">    cf_digest keyd;	<span class="comment">//20字节哈希值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset: 24</span></span><br><span class="line">    <span class="type">uint64_t</span> left_h: <span class="number">40</span>;	<span class="comment">//红黑树左指针（实际是handle）</span></span><br><span class="line">    <span class="type">uint64_t</span> right_h: <span class="number">40</span>;	<span class="comment">//红黑树右指针（实际是handle）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset: 34</span></span><br><span class="line">    <span class="type">uint16_t</span> set_id_bits: <span class="number">12</span>;	<span class="comment">// 对应的set的id号，可以直接查询到set在内存的数据结构的地址</span></span><br><span class="line">    <span class="comment">/* 下面四个结构不涉及核心过程，可不管 */</span></span><br><span class="line">    <span class="type">uint16_t</span> in_sindex: <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint16_t</span> xdr_bin_cemetery: <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint16_t</span> has_bin_meta: <span class="number">1</span>; <span class="comment">// named for warm restart erase (was for old DIM)</span></span><br><span class="line">    <span class="type">uint16_t</span> xdr_write: <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset: 36</span></span><br><span class="line">    <span class="type">uint32_t</span> xdr_tombstone: <span class="number">1</span>;  </span><br><span class="line">    <span class="type">uint32_t</span> xdr_nsup_tombstone: <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32_t</span> void_time: <span class="number">30</span>;		<span class="comment">// 过期时间，若没设置过期，该值会取uint32的最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset: 40</span></span><br><span class="line">    <span class="type">uint64_t</span> last_update_time: <span class="number">40</span>;	<span class="comment">//最新更新时间</span></span><br><span class="line">    <span class="type">uint64_t</span> generation: <span class="number">16</span>;	<span class="comment">//版本号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset: 47</span></span><br><span class="line">    <span class="comment">// Used by the storage engines.</span></span><br><span class="line">    <span class="type">uint64_t</span> rblock_id: <span class="number">37</span>;		<span class="comment">// can address 2^37 * 16b = 2Tb drive，对应rblock块号</span></span><br><span class="line">    <span class="type">uint64_t</span> n_rblocks: <span class="number">19</span>;		<span class="comment">// is enough for 8Mb/16b = 512K rblocks，使用了多少个rblock</span></span><br><span class="line">    <span class="type">uint64_t</span> file_id: <span class="number">7</span>;		<span class="comment">// 对应的ssd设备号</span></span><br><span class="line">    <span class="type">uint64_t</span> key_stored: <span class="number">1</span>;		<span class="comment">// ssd的块上有没有存key的值(因为有可能不保留key原值，只有hash)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset: 55</span></span><br><span class="line">    <span class="comment">/* 集群交流用的 */</span></span><br><span class="line">    <span class="type">uint8_t</span> repl_state: <span class="number">2</span>;</span><br><span class="line">    <span class="type">uint8_t</span> tombstone: <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint8_t</span> cenotaph: <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint8_t</span> : <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset: 56</span></span><br><span class="line">    <span class="comment">// These 8 bytes are currently unused.</span></span><br><span class="line">    <span class="type">void</span>* dim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// final size: 64</span></span><br><span class="line"></span><br><span class="line">&#125; __attribute__ ((__packed__)) as_index;</span><br></pre></td></tr></table></figure>
<p>获取一个record数据，若不存在，则插入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If there&#x27;s an element with specified digest in the tree, return a locked</span></span><br><span class="line"><span class="comment">// reference to it in index_ref. If not, create an element with this digest,</span></span><br><span class="line"><span class="comment">// insert it into the tree, and return a locked reference to it in index_ref.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns:</span></span><br><span class="line"><span class="comment">//		 1 - created and inserted (reference returned in index_ref)</span></span><br><span class="line"><span class="comment">//		 0 - found already existing (reference returned in index_ref)</span></span><br><span class="line"><span class="comment">//		-1 - error - could not allocate arena stage</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">as_index_get_insert_vlock</span><span class="params">(as_index_tree* tree, <span class="type">const</span> cf_digest* keyd,</span></span></span><br><span class="line"><span class="params"><span class="function">        as_index_ref* index_ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    as_index_sprig isprig;</span><br><span class="line">    <span class="built_in">as_index_sprig_from_keyd</span>(tree, &amp;isprig, keyd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">as_index_sprig_get_insert_vlock</span>(&amp;isprig, tree-&gt;id, keyd,</span><br><span class="line">            index_ref);</span><br><span class="line">    <span class="comment">// 该树总元素数量加1</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">as_incr_uint64</span>(&amp;tree-&gt;n_elements);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下函数即红黑树的查找过程，如果找不到，创建一个树节点，并返回对应的index_ref，注意hold住了锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">as_index_sprig_get_insert_vlock</span><span class="params">(as_index_sprig* isprig, <span class="type">uint8_t</span> tree_id,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> cf_digest* keyd, as_index_ref* index_ref)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cmp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use a stack as_index object for the root&#x27;s parent, for convenience.</span></span><br><span class="line">    as_index root_parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save parents as we search for the specified element&#x27;s insertion point.</span></span><br><span class="line">    as_index_ele eles[<span class="number">64</span>]; <span class="comment">// must be &gt;= (24 * 2)</span></span><br><span class="line">    as_index_ele* ele;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ele = eles;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cf_mutex_lock</span>(&amp;isprig-&gt;pair-&gt;lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Search for the specified element, or a parent to insert it under.</span></span><br><span class="line"></span><br><span class="line">        root_parent.left_h = isprig-&gt;sprig-&gt;root_h;</span><br><span class="line">        root_parent.color = BLACK;</span><br><span class="line"></span><br><span class="line">        ele-&gt;parent = <span class="literal">NULL</span>; <span class="comment">// we&#x27;ll never look this far up</span></span><br><span class="line">        ele-&gt;me_h = <span class="number">0</span>; <span class="comment">// root parent has no handle, never used</span></span><br><span class="line">        ele-&gt;me = &amp;root_parent;</span><br><span class="line"></span><br><span class="line">        cf_arenax_handle t_h = isprig-&gt;sprig-&gt;root_h;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (t_h != SENTINEL_H) &#123;</span><br><span class="line">            as_index* t = <span class="built_in">RESOLVE</span>(t_h);</span><br><span class="line"></span><br><span class="line">            ele++;</span><br><span class="line">            ele-&gt;parent = ele - <span class="number">1</span>;</span><br><span class="line">            ele-&gt;me_h = t_h;</span><br><span class="line">            ele-&gt;me = t;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">as_arch_prefetch_nt</span>(t);</span><br><span class="line">            <span class="comment">// 如果找到了，则直接赋值返回，可以看到用hash值做的比较</span></span><br><span class="line">            <span class="keyword">if</span> ((cmp = <span class="built_in">cf_digest_compare</span>(keyd, &amp;t-&gt;keyd)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// The element already exists, simply return it.</span></span><br><span class="line"></span><br><span class="line">                index_ref-&gt;r = t;</span><br><span class="line">                index_ref-&gt;r_h = t_h;</span><br><span class="line"></span><br><span class="line">                index_ref-&gt;puddle = isprig-&gt;puddle;</span><br><span class="line">                index_ref-&gt;olock = &amp;isprig-&gt;pair-&gt;lock;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            t_h = cmp &gt; <span class="number">0</span> ? t-&gt;left_h : t-&gt;right_h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We didn&#x27;t find the tree element, so we&#x27;ll be inserting it.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cf_mutex_trylock</span>(&amp;isprig-&gt;pair-&gt;reduce_lock)) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// no reduce in progress - go ahead and insert new element</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The tree is being reduced - could take long, unlock so reads and</span></span><br><span class="line">        <span class="comment">// overwrites aren&#x27;t blocked.</span></span><br><span class="line">        <span class="built_in">cf_mutex_unlock</span>(&amp;isprig-&gt;pair-&gt;lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait until the tree reduce is done...</span></span><br><span class="line">        <span class="built_in">cf_mutex_lock</span>(&amp;isprig-&gt;pair-&gt;reduce_lock);</span><br><span class="line">        <span class="built_in">cf_mutex_unlock</span>(&amp;isprig-&gt;pair-&gt;reduce_lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... and start over - we unlocked, so the tree may have changed.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a new element and insert it.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save the root so we can detect whether it changes.</span></span><br><span class="line">    cf_arenax_handle old_root = isprig-&gt;sprig-&gt;root_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个内存索引结构，会先尝试从free-list取，没有则分配</span></span><br><span class="line">    cf_arenax_handle n_h = <span class="built_in">cf_arenax_alloc</span>(isprig-&gt;arena, isprig-&gt;puddle);</span><br><span class="line">    ...	</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 后续代码均为将该索引节点插入到红黑树中*/</span></span><br><span class="line">    as_index* n = <span class="built_in">RESOLVE</span>(n_h);</span><br><span class="line"></span><br><span class="line">    *n = (as_index)&#123;</span><br><span class="line">        .tree_id = tree_id,</span><br><span class="line">        .keyd = *keyd,</span><br><span class="line">        .left_h = SENTINEL_H,</span><br><span class="line">        .right_h = SENTINEL_H,</span><br><span class="line">        .color = RED</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert the new element n under parent ele.</span></span><br><span class="line">    <span class="keyword">if</span> (ele-&gt;me == &amp;root_parent || <span class="number">0</span> &lt; cmp) &#123;</span><br><span class="line">        ele-&gt;me-&gt;left_h = n_h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ele-&gt;me-&gt;right_h = n_h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ele++;</span><br><span class="line">    ele-&gt;parent = ele - <span class="number">1</span>;</span><br><span class="line">    ele-&gt;me_h = n_h;</span><br><span class="line">    ele-&gt;me = n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rebalance the sprig as needed.</span></span><br><span class="line">    <span class="built_in">as_index_sprig_insert_rebalance</span>(isprig, &amp;root_parent, ele);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If insertion caused the root to change, save the new root.</span></span><br><span class="line">    <span class="keyword">if</span> (root_parent.left_h != old_root) &#123;</span><br><span class="line">        isprig-&gt;sprig-&gt;root_h = root_parent.left_h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cf_mutex_unlock</span>(&amp;isprig-&gt;pair-&gt;reduce_lock);</span><br><span class="line"></span><br><span class="line">    index_ref-&gt;r = n;</span><br><span class="line">    index_ref-&gt;r_h = n_h;</span><br><span class="line"></span><br><span class="line">    index_ref-&gt;puddle = isprig-&gt;puddle;</span><br><span class="line">    index_ref-&gt;olock = &amp;isprig-&gt;pair-&gt;lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除一个key的操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单纯从索引树中移除节点</span></span><br><span class="line"><span class="built_in">as_index_delete</span>(p_partition-&gt;tree, &amp;flat-&gt;keyd);</span><br><span class="line"><span class="comment">// 真正释放索引结构到free_list</span></span><br><span class="line"><span class="built_in">as_record_done</span>(&amp;r_ref, ns);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">as_record_destroy</span><span class="params">(as_record* r, as_namespace* ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 仅做统计（减少索引对应set的record数量，ns的record数量）</span></span><br><span class="line">    <span class="built_in">as_record_drop_stats</span>(r, ns);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ssd操作，真正从存储引擎中删除节点</span></span><br><span class="line">    <span class="built_in">as_storage_destroy_record</span>(ns, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心函数为<code>ssd_block_free</code>，相关逻辑在ssd管理章节给出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">as_storage_destroy_record_ssd</span><span class="params">(as_namespace *ns, as_record *r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">STORAGE_RBLOCK_IS_VALID</span>(r-&gt;rblock_id) &amp;&amp; r-&gt;n_rblocks != <span class="number">0</span>) &#123;</span><br><span class="line">        drv_ssds *ssds = (drv_ssds*)ns-&gt;storage_private;</span><br><span class="line">        drv_ssd *ssd = &amp;ssds-&gt;ssds[r-&gt;file_id];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ssd_block_free</span>(ssd, r-&gt;rblock_id, r-&gt;n_rblocks, <span class="string">&quot;destroy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">as_namespace_adjust_set_data_used_bytes</span>(ns, <span class="built_in">as_index_get_set_id</span>(r),</span><br><span class="line">                -(<span class="type">int64_t</span>)<span class="built_in">N_RBLOCKS_TO_SIZE</span>(r-&gt;n_rblocks));</span><br><span class="line"></span><br><span class="line">        r-&gt;rblock_id = <span class="number">0</span>;</span><br><span class="line">        r-&gt;n_rblocks = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主索引内存管理"><a href="#主索引内存管理" class="headerlink" title="主索引内存管理"></a>主索引内存管理</h2><p>Aerospike会为每个namespace创建一个对应的arena。由于sprig的树节点(as_index)结构为定长的64byte，Aerospike使用了自己设计的arenax结构来管理该定长数据。</p>
<p><img src="/2025-04-19-aerospike%E5%AD%A6%E4%B9%A0(2)-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%B4%A2%E5%BC%95%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png"></p>
<p>上图为arenax的组织结构。arenax为两层内存分配方式结构：</p>
<ul>
<li>第一层为stage，总共有256个stage，每个stage指向一块定长的内存区域（1G)。第二层，则为stage指向的这片内存区域，该片区域根据as_index的大小被切分成1677721块(1G&#x2F;64)。</li>
<li>arenax维护了一个free list。当有as_index结构free时，则放回到该free list的头部。arenax实际维护的是该free list的头。当有malloc请求时，arenax首先会查看free list里面是否还有空闲slot，如果有的话，则将free list头上的slot返回给调用方。</li>
<li>如果free list没有空闲slot，则从根据当前<code>stage_id（at_stage_id）</code>以及对应的<code>element_id(at_element_id)</code>拿到可用的slot，将该slot返回给调用方，并顺势调整<code>at_stage_id, at_element_id</code>。</li>
<li>返回给调用方的是<code>cf_arenax_handle（uint64_t)</code>，该句柄为40位，并不是内存地址，而是一个两级索引，前12位为第1级stage索引，后28位为第2级elemnt索引。在使用时，需要通过handle调用接口转换出指定的内存指针: <code>void* cf_arenax_resolve(cf_arenax* arena, cf_arenax_handle h)</code>。</li>
<li>光从arenax的组织来看，单台server，一个namespace的索引节点上限(as_index)数量：<code>stage_count * slot_count_per_stage = 256*16777216 = 4294967296</code>。基本上算无上限。</li>
<li>为区分非法handle，stage[0]的slot[0]不做分配，初始状态是at_stage_id &#x3D; 0, at_element_id &#x3D; 1。</li>
</ul>
<h2 id="wblock缓存"><a href="#wblock缓存" class="headerlink" title="wblock缓存"></a>wblock缓存</h2><p>即数据块缓存。这里不详细阐述原理，原理将在ssd引擎一章统一阐述。</p>
<p>这里给出结论，在默认wblock为1M的情况下，数据块内存缓存默认为256M。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025-04-10-aerospike%E5%AD%A6%E4%B9%A0(1)-SDK%E6%8F%90%E4%BE%9B%E7%9A%84%E8%83%BD%E5%8A%9B/" rel="prev" title="aerospike学习(1)-SDK提供的能力">
                  <i class="fa fa-angle-left"></i> aerospike学习(1)-SDK提供的能力
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025-04-28-hash%E5%BC%95%E6%93%8E%E8%AE%BE%E8%AE%A1%E9%9A%BE%E7%82%B9(1)-%E9%9D%9E%E5%8E%9F%E5%AD%90%E6%80%A7%E8%AF%BB%E5%86%99/" rel="next" title="hash引擎设计难点(1)-非原子性读写">
                  hash引擎设计难点(1)-非原子性读写 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Corgis</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
