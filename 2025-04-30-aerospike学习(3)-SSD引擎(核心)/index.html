<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/corgis.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/corgis.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scut-corgis.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="aerospike-SSD引擎引言 - 从ssd工作原理出发经过深入的学习后，我逐渐认识到，aerospike最核心的模块就是SSD引擎，其为SSD专门制作和优化的IO引擎，具备理论上限的吞吐能力。其低时延、高吞吐的最重要的原因就是其SSD引擎。 aerospike的内存索引结构，wblock的数据缓存swb结构，或是数据在磁盘上的组织结构，均基于ssd的block块设计。充分利用了ssd的物理层">
<meta property="og:type" content="article">
<meta property="og:title" content="aerospike学习(3)-SSD引擎(核心)">
<meta property="og:url" content="https://scut-corgis.github.io/2025-04-30-aerospike%E5%AD%A6%E4%B9%A0(3)-SSD%E5%BC%95%E6%93%8E(%E6%A0%B8%E5%BF%83)/index.html">
<meta property="og:site_name" content="corgis的笔记">
<meta property="og:description" content="aerospike-SSD引擎引言 - 从ssd工作原理出发经过深入的学习后，我逐渐认识到，aerospike最核心的模块就是SSD引擎，其为SSD专门制作和优化的IO引擎，具备理论上限的吞吐能力。其低时延、高吞吐的最重要的原因就是其SSD引擎。 aerospike的内存索引结构，wblock的数据缓存swb结构，或是数据在磁盘上的组织结构，均基于ssd的block块设计。充分利用了ssd的物理层">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://scut-corgis.github.io/2025-04-30-aerospike%E5%AD%A6%E4%B9%A0(3)-SSD%E5%BC%95%E6%93%8E(%E6%A0%B8%E5%BF%83)/ssd%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://scut-corgis.github.io/2025-04-30-aerospike%E5%AD%A6%E4%B9%A0(3)-SSD%E5%BC%95%E6%93%8E(%E6%A0%B8%E5%BF%83)/ssd%E5%9D%97%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84.svg">
<meta property="og:image" content="https://scut-corgis.github.io/2025-04-30-aerospike%E5%AD%A6%E4%B9%A0(3)-SSD%E5%BC%95%E6%93%8E(%E6%A0%B8%E5%BF%83)/%E5%86%85%E5%AD%98%E7%B4%A2%E5%BC%95%E4%B8%8Essd%E4%BA%A4%E4%BA%92.svg">
<meta property="og:image" content="https://scut-corgis.github.io/2025-04-30-aerospike%E5%AD%A6%E4%B9%A0(3)-SSD%E5%BC%95%E6%93%8E(%E6%A0%B8%E5%BF%83)/wblock%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86.svg">
<meta property="og:image" content="https://scut-corgis.github.io/2025-04-30-aerospike%E5%AD%A6%E4%B9%A0(3)-SSD%E5%BC%95%E6%93%8E(%E6%A0%B8%E5%BF%83)/wblock%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB.svg">
<meta property="article:published_time" content="2025-04-30T13:41:51.000Z">
<meta property="article:modified_time" content="2025-04-28T07:54:08.823Z">
<meta property="article:author" content="Corgis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://scut-corgis.github.io/2025-04-30-aerospike%E5%AD%A6%E4%B9%A0(3)-SSD%E5%BC%95%E6%93%8E(%E6%A0%B8%E5%BF%83)/ssd%E7%BB%93%E6%9E%84.png">


<link rel="canonical" href="https://scut-corgis.github.io/2025-04-30-aerospike%E5%AD%A6%E4%B9%A0(3)-SSD%E5%BC%95%E6%93%8E(%E6%A0%B8%E5%BF%83)/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://scut-corgis.github.io/2025-04-30-aerospike%E5%AD%A6%E4%B9%A0(3)-SSD%E5%BC%95%E6%93%8E(%E6%A0%B8%E5%BF%83)/","path":"2025-04-30-aerospike学习(3)-SSD引擎(核心)/","title":"aerospike学习(3)-SSD引擎(核心)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>aerospike学习(3)-SSD引擎(核心) | corgis的笔记</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">corgis的笔记</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#aerospike-SSD%E5%BC%95%E6%93%8E"><span class="nav-number">1.</span> <span class="nav-text">aerospike-SSD引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E8%A8%80-%E4%BB%8Essd%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%87%BA%E5%8F%91"><span class="nav-number">1.1.</span> <span class="nav-text">引言 - 从ssd工作原理出发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E8%A7%88"><span class="nav-number">1.2.</span> <span class="nav-text">总览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%8Essd"><span class="nav-number">1.2.1.</span> <span class="nav-text">读写线程模型与ssd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ssd%E5%88%86%E5%8C%BA"><span class="nav-number">1.2.2.</span> <span class="nav-text">ssd分区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E7%9B%98%E6%89%AB%E6%8F%8F"><span class="nav-number">1.4.</span> <span class="nav-text">全盘扫描</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86"><span class="nav-number">1.5.</span> <span class="nav-text">垃圾回收与碎片整理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wblock%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98"><span class="nav-number">1.6.</span> <span class="nav-text">wblock数据缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E6%91%98%E5%BD%95%E4%B8%8E%E6%B3%A8%E9%87%8A"><span class="nav-number">1.7.</span> <span class="nav-text">日志打印摘录与注释</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Corgis"
      src="/images/corgis.jpg">
  <p class="site-author-name" itemprop="name">Corgis</p>
  <div class="site-description" itemprop="description">用于成长过程中，记录值得对外分享的技术，如开源代码理解、国外课程项目，个人对一些领域的心得等</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://scut-corgis.github.io/2025-04-30-aerospike%E5%AD%A6%E4%B9%A0(3)-SSD%E5%BC%95%E6%93%8E(%E6%A0%B8%E5%BF%83)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/corgis.jpg">
      <meta itemprop="name" content="Corgis">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corgis的笔记">
      <meta itemprop="description" content="用于成长过程中，记录值得对外分享的技术，如开源代码理解、国外课程项目，个人对一些领域的心得等">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="aerospike学习(3)-SSD引擎(核心) | corgis的笔记">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          aerospike学习(3)-SSD引擎(核心)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-04-30 21:41:51" itemprop="dateCreated datePublished" datetime="2025-04-30T21:41:51+08:00">2025-04-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%93%88%E5%B8%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">哈希存储引擎</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="aerospike-SSD引擎"><a href="#aerospike-SSD引擎" class="headerlink" title="aerospike-SSD引擎"></a>aerospike-SSD引擎</h1><h2 id="引言-从ssd工作原理出发"><a href="#引言-从ssd工作原理出发" class="headerlink" title="引言 - 从ssd工作原理出发"></a>引言 - 从ssd工作原理出发</h2><p>经过深入的学习后，我逐渐认识到，aerospike最核心的模块就是SSD引擎，其为SSD专门制作和优化的IO引擎，具备理论上限的吞吐能力。其低时延、高吞吐的最重要的原因就是其SSD引擎。</p>
<p>aerospike的内存索引结构，wblock的数据缓存swb结构，或是数据在磁盘上的组织结构，均基于ssd的block块设计。充分利用了ssd的物理层面上的特性，如极快的随机寻址后按块擦除或整块写能力。其直接操作ssd的方法，使得ssd硬件驱动自身几乎不需要做任何的垃圾回收，同时充分的利用了ssd多路复用，榨干了ssd的io能力。</p>
<p>因为其读写过程几乎完全随机寻址的访问block块设计，所以相对于传统的机械硬盘便不那么“吃香”，但是考虑到当前ssd的性能远超hdd，且成本已经越来越低，各个公司的主存储硬件基本都采用了ssd，所以aerospike是一种先进的架构模式。</p>
<p>而它这种ssd引擎的设计，天生适合做哈希引擎的存储底座。</p>
<p>一个标准的ssd结构大致如下图所示<br><img src="/2025-04-30-aerospike%E5%AD%A6%E4%B9%A0(3)-SSD%E5%BC%95%E6%93%8E(%E6%A0%B8%E5%BF%83)/ssd%E7%BB%93%E6%9E%84.png"><br>比如</p>
<ul>
<li>页大小：4kb</li>
<li>块大小: 128Kb</li>
</ul>
<p>ssd以页为单位读写，以块为单位擦除。寻址时间是几乎可以不计的。</p>
<p>操作系统通过传给ssd硬件驱动页号，对其页进行读写。在ssd内部，每个页只允许写入一次，如果第二次写入，则必须搬迁到其他的页中，并擦除原来页所在的整个块。</p>
<p>对于传统的lsm结构，如rocksdb，其追加写模式最初是为机械硬盘设计的，能减少占比最大的寻道时间。但一定程度上也对ssd结构友好。大量的追加写会使得操作系统尽量传连续的页号给ssd，ssd的ftl也会尽量使其能够在同一个块中进行写入，保证每个页只会写入一次，减少了因搬迁造成的性能损耗。</p>
<p>但显然这有缺陷，首先，上层无法控制操作系统传多少连续的页号，举个例子，可能一个块有32个页，而上层传的地址范围，对应页号到操作系统可能是间断的，比如3、7、9个页，那么就做了三次访问ssd的io操作。当然上面的这种情况操作系统会做足够的优化，只要你不主动调用sync刷盘，操作系统会自己决定什么时候刷page cache，影响不算大。第二种情况是无法控制一个文件会不会跨块，我们知道compaction涉及到删除文件，那么删除一个文件可能会擦除别的文件的块，造成ssd内部的页数据搬运。</p>
<p>再者，lsm不可避免的引入了读放大和写放大。读操作而言，如果内存中读不到数据，读可能会读多层sst文件。写操作而言，每一个写操作最终可能有10多倍的写io放大，浪费了很多ssd的带宽。</p>
<p>对于顺序写文件模型，内核实现存在一个普遍的问题，即只能单线程写wal。比如对于rocksdb，一般会选一个writer_leader出来做某批write_batch的write()系统调用，并调用sync刷盘。但as可以多线程写盘，最大化利用ssd写带宽。</p>
<p>总的来说，lsm树性能很好，但不是对ssd结构最优的。大致有以下几点：</p>
<ol>
<li>访问ssd硬件次数不可控</li>
<li>有多余的块擦除和搬运</li>
<li>不可避免的依赖操作系统的黑盒操作和长链路</li>
<li>compaction阶段势必会占用大量的ssd带宽，造成性能抖动</li>
<li>读写放大严重，浪费ssd带宽 (<strong>性能影响最大因素</strong>)</li>
<li>顺序写文件模型只能单线程写wal。</li>
</ol>
<p>而aerospike的ssd引擎解决了或缓解了上面这些问题。第1-2点问题是推导的，但笔者使用fio做了详细的各种场景测试，走文件系统或裸设备，开关direct-io，4kb与128kb读写等，基本证明了上面的猜想。</p>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>主要从上层架构上讲清楚其ssd管理模型。</p>
<p>aerospike的ssd管理方式，和本身ssd的底层块擦写原理契合，而基于磁盘的数据库引擎（如rocksdb）其瓶颈基本都在IO上，因此aerospike依靠其ssd引擎，能实现较高的qps和稳定的极低的延时，原因在于没有操作系统的文件系统链路，延时在纯读写ssd块数据等待硬件响应完成上，配合代码控制读写块的并发度，延时是可预测和可控的。如果命中buf(数量可配)缓存时延就更低。</p>
<p>因为直接和ssd通信，根据ssd的种类如NVME的PCIE通道数，能够更好的设置写盘的线程数，而传统的基于操作系统的文件系统IO，因为操作系统链路的黑盒，很难设置读写IO线程数。</p>
<p>首先是块组织，aerospike将一个ssd设备会组织为如下图中的形式。其只会以某个可配置值wblock_size（默认1M）覆盖写ssd，永不修改其中某一部分或者覆盖0值。</p>
<p>当然，覆盖写某个逻辑块，在ssd硬件自身会做擦除原块，并取一个崭新块刷入。但是因为数据库自身不需要将块清0写入，所以变相减少了块的io次数。同时以ssd的底层块为整数倍做io，使得ssd无需为了其空洞页做垃圾回收（即搬运迁移操作），这在用操作系统的io是做不到的。</p>
<p>当然即使上层传了一个连续的块地址，用direct-io，如<code>pwrite</code>0～128kb，操作系统实际上也是用的LBA逻辑块号以最小io大小如4kb对齐，传递给的ssd驱动。所以经过了ssd的ftl也不一定对应于一个ssd的物理块，所以上面的as减少了垃圾回收的次数属于一种推论，实际上还得看ftl的算法，即ssd自身硬件有没有将这批连续的逻辑页号真正映射到物理页。</p>
<p><img src="/2025-04-30-aerospike%E5%AD%A6%E4%B9%A0(3)-SSD%E5%BC%95%E6%93%8E(%E6%A0%B8%E5%BF%83)/ssd%E5%9D%97%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84.svg"></p>
<p>aerospike管理的最小单元为rblock（固定为16字节）。索引定位数据位置通过rblock_id定位。对于wblock，其内存维护了wblock_state结构管理ssd所有wblock状态。<br><img src="/2025-04-30-aerospike%E5%AD%A6%E4%B9%A0(3)-SSD%E5%BC%95%E6%93%8E(%E6%A0%B8%E5%BF%83)/%E5%86%85%E5%AD%98%E7%B4%A2%E5%BC%95%E4%B8%8Essd%E4%BA%A4%E4%BA%92.svg"></p>
<p>当我们删除一条record，aerospike会维护红黑树结构，直接删除内存索引树节点。并减少wblock_state结构中对该wblock的使用大小inuse。注意<strong>没有做任何的io操作！。</strong></p>
<ul>
<li>一旦inuse降为0，将该wblock状态标记为free，并纳入wblock的free队列，直接可以复用，复用即后续覆盖写，因此该处没有擦除动作。</li>
<li>一旦碎片率过高（默认50%），会将该wblock传递的碎片整理线程，碎片整理线程会读出该wblock的全部record，然后迁移走，到一个新的wblock中。</li>
</ul>
<p>碎片整理的迁移过程中，会记录该wblock迁往的目标wblock列表。直到目标wblock对应的swb缓存全部刷盘完毕，该源wblock才可回收。<strong>大多少情况下只会迁往某一个wblock中</strong>。</p>
<p>以2个低利用率的wblock为例，其被碎片整理线程迁往了某个wblock中。后被刷屏线程刷盘持久化，再回收该低利用率的wblock。</p>
<p><img src="/2025-04-30-aerospike%E5%AD%A6%E4%B9%A0(3)-SSD%E5%BC%95%E6%93%8E(%E6%A0%B8%E5%BF%83)/wblock%E7%A2%8E%E7%89%87%E6%95%B4%E7%90%86.svg"></p>
<p>因此，aerospike的删除操作并非持久删除。宕机重启若不进行主从状态同步，删除数据会back回内存索引。</p>
<p>刷盘后，wblock_state关联的ssd数据缓存swb会判断当前buf数量是否超过设置值（默认256个缓存buf）。没超过则不重置swb，减少频繁的碎片清理或ssd读取的io操作。利用了wblock访问的局部性。</p>
<p>aerospike默认的wblock缓存数据较小，以wblock为1M为例，默认只会缓存256个wblock在内存中。其缓存时机为刷盘后不释放。如在刷盘后处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ssd_post_write</span>(drv_ssd *ssd, ssd_write_buf *swb)</span><br></pre></td></tr></table></figure>
<p>函数中，刷完盘后并不会立马释放swb，而是判断是否大于了缓存数量大小，如果大于后再释放swb。</p>
<p>而对于读record操作，也是先看该缓存是否存在，不存在才重新从ssd中读<strong>record</strong>。</p>
<p>这里有很细节的地方，没有把整个wblock都读进来导致放大写，而是以ssd的最小io大小做地址对齐，读ssd的整数个page，囊括整个record数据，再通过record_size和起始地址等信息，取出需要的部分。</p>
<blockquote>
<p>相当于读操作也是跟ssd底层的按page读原理对应，该读多少读多少，不会放大读。读进来后也不会填充缓存，用完内存直接释放。</p>
</blockquote>
<p>完整的wblock状态转移图如下<br><img src="/2025-04-30-aerospike%E5%AD%A6%E4%B9%A0(3)-SSD%E5%BC%95%E6%93%8E(%E6%A0%B8%E5%BF%83)/wblock%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB.svg"></p>
<p>as的写瓶颈取决于刷盘线程，如果刷盘队列中大于64M（默认），则开始拒写。如果刷盘队列大于192M，defrag线程会睡眠等待。</p>
<h3 id="读写线程模型与ssd"><a href="#读写线程模型与ssd" class="headerlink" title="读写线程模型与ssd"></a>读写线程模型与ssd</h3><p>在aerospike的ssd模式下，默认会开cpu数量五倍的服务线程数。服务线程有以下特点：</p>
<ul>
<li>每一个线程有一个epoll，管理一批client连接的fd</li>
<li>负责连接的tcp读写、应用层协议解析、以及读写全过程、直到回包。即负责一个连接的全生命周期</li>
<li>连接的分发方式采用round_robin给各个服务线程。</li>
</ul>
<p>以读操作为例。假如读的record在对应的wblock已经在内存中有缓存buf（前文提到的默认256个刷盘后不释放的buf）。则直接读出结果，否则<strong>按页按需</strong>读取ssd，读完后立即释放内存。</p>
<p>写操作。对于一条新纪录：</p>
<ol>
<li>获取或创建该记录的内存索引</li>
<li>获取一个swb（ssd_write_buffer，每个ssd最多同时3个写缓冲swb），往该swb中追加写入记录，若记录写满该swb，将swb追加到刷盘队列中，让刷盘线程刷盘。</li>
<li>若上一步写ssd成功，将内存索引指向该新的位置。</li>
<li>如果该写操作覆盖了老的记录，减少老记录对于wblock_state的size值，若老wblock碎片率高，则转交给碎片整理线程处理。</li>
</ol>
<h3 id="ssd分区"><a href="#ssd分区" class="headerlink" title="ssd分区"></a>ssd分区</h3><p><strong>值得关注的是</strong>:aerospike正常运行后几乎只有刷盘线程在写盘，对于NVME设备，有4个PCIE通道，aerospike建议将该设备划分为多个分区(比如最少4个，最佳实践是小于cpu数量，用bench测)，这样代码就会创建多个写线程能同时刷盘，最大化IO。假如一个NVME设备用原始裸设备配置在aerospike上，只会创建一个写线程，在满负载时，用linux命令<code>iostat</code>也会显示100%的磁盘使用率，但是可能只是用满了一个PCIE通道。</p>
<p><a target="_blank" rel="noopener" href="https://aerospike.com/docs/database/manage/planning/ssd/setup/#partition-your-flash-devices">https://aerospike.com/docs/database/manage/planning/ssd/setup/#partition-your-flash-devices</a></p>
<p>测试了一下分区带来的影响。</p>
<p>当整块ssd不分区的时候。测试命令如下。写命令比例100%</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./asbench -h infra-bjx-e20-139.idchb1az1.hb1.kwaidc.com -n test -s aerospike -b f -k 100000000 -o S200 -w RU,0 -z 64 -t 600 -prefix_str test -R</span><br></pre></td></tr></table></figure>

<p>iostat显示的结果如下，看到说io已经满负载了。最终稳定tps约78.7W(若100%读为104W)，ssd带宽约为3.3G,写带宽约228M。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iostat -x -d 5</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">nvme0n1           0.00     0.00 770913.40  640.80 3351662.40 228760.80     9.28     3.80    0.15    0.15    1.01   0.00 100.02</span><br></pre></td></tr></table></figure>

<p>然后我将原ssd分成了4个分区，配置文件也修改如下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">namespace <span class="built_in">test</span> &#123;</span><br><span class="line">  replication-factor 2</span><br><span class="line">  storage-engine device &#123;</span><br><span class="line">    <span class="comment"># Use one or more lines like those below with actual device paths.</span></span><br><span class="line">    device /dev/nvme0n1p1</span><br><span class="line">    device /dev/nvme0n1p2</span><br><span class="line">    device /dev/nvme0n1p3</span><br><span class="line">    device /dev/nvme0n1p4</span><br><span class="line">    cold-start-empty <span class="literal">true</span></span><br><span class="line">    <span class="comment"># write-block-size 128K</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再进行了一次测试，tps 111.5W(换100%读112.3W，几乎一模一样), 读带宽到了3.4G，写带宽到了408M。tps表现增加了整整40W，写带宽翻了一倍！</p>
<blockquote>
<p>提升相当巨大。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iostat -x -d 5</span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">nvme0n1           0.00     0.00 734149.00 1102.20 3425954.40 408572.80    10.43     5.09    0.17    0.16    1.12   0.00 100.00</span><br></pre></td></tr></table></figure>

<p>结果分析：只能说很好很强大，读写吞吐完全一致，单nvme的ssd能达到100多万的qps。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在as启动阶段，会对ssd进行初始化，主要是扫描一遍ssd的全部数据，填充相应的partition索引，主要会经历以下流程</p>
<ol>
<li>硬件信息获取与初始化<ul>
<li>获取配置文件设置的写块大小（默认1M），配置相关的写队列缓存。</li>
<li>获取ssd最小一次io的大小, 比如4096字节</li>
<li>获取ssd总大小，以块大小对齐</li>
<li>初始化记录每个块状态的结构，标识每个块未使用</li>
<li>与ssd交互的驱动队列初始化</li>
</ul>
</li>
<li>header读取与校验<ul>
<li>读取ssd最前的8M空间，校验是否满足as的header格式，若不是，表示ssd未格式化，直接退出</li>
<li>将读出的header初始化结构体。header里面记录了一系列的元信息，包括对应的namespace名字、partition列表等等</li>
<li>根据header初始化partition的索引树结构</li>
</ul>
</li>
<li>ssd全盘扫描，构建内存索引<ul>
<li>as的块设计，会将ssd数据放在序号小的block_id上，因此从block_id从小到大扫，实际是扫到连续的10个未使用的block时停止继续扫描，认为完毕。</li>
<li>2T的ssd，扫描30%（数据存储使用30%），用时约2小时</li>
</ul>
</li>
</ol>
<p>以下为ssd初始化结构的<strong>核心源码摘录与注释</strong>。（删除了所有非核心链路的代码）</p>
<p>main函数中的第一个ssd入口为<code>as_storage_init_ssd</code>，该函数完成了除全盘扫描以外的全部操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ssd初始化</span></span><br><span class="line"><span class="built_in">as_storage_init_ssd</span>(as_namespace *ns) &#123;</span><br><span class="line">    drv_ssds *ssds;</span><br><span class="line">    <span class="built_in">ssd_init_devices</span>(ns, &amp;ssds);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    ns-&gt;storage_max_write_cache = 64M  记录最大写buffer</span></span><br><span class="line"><span class="comment">    ns-&gt;storage_write_block_size = 1M  一次操作的ssd块大小</span></span><br><span class="line"><span class="comment">    ns-&gt;storage_max_write_q = 64 计算出最多64个块缓冲</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ns-&gt;storage_max_write_q = (<span class="type">uint32_t</span>)</span><br><span class="line">            (ssds-&gt;n_ssds * ns-&gt;storage_max_write_cache /</span><br><span class="line">                    ns-&gt;storage_write_block_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 碎片清理百分比，默认50%，当垃圾超过50%时开始ssd垃圾回收</span></span><br><span class="line">    ns-&gt;defrag_lwm_size =</span><br><span class="line">            (ns-&gt;storage_write_block_size * ns-&gt;storage_defrag_lwm_pct) / <span class="number">100</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 留一个DRV_HEADER_SIZE大小的作为ssd驱动头部份（8M），得出第一个块id为8</span></span><br><span class="line">    <span class="type">uint32_t</span> first_wblock_id = DRV_HEADER_SIZE / ns-&gt;storage_write_block_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化drv_ssd structures</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ssds-&gt;n_ssds; i++) &#123;</span><br><span class="line">        drv_ssd *ssd = &amp;ssds-&gt;ssds[i];</span><br><span class="line"></span><br><span class="line">        ssd-&gt;ns = ns;</span><br><span class="line">        ssd-&gt;file_id = i;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        ssd-&gt;running = <span class="literal">true</span>;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 简单赋值给结构题</span></span><br><span class="line">        ssd-&gt;write_block_size = ns-&gt;storage_write_block_size;</span><br><span class="line">        ssd-&gt;first_wblock_id = first_wblock_id;</span><br><span class="line">        ssd-&gt;pristine_wblock_id = first_wblock_id;</span><br><span class="line">        <span class="comment">/* 对所有的ssd的block，申请了对应的block_state结构，标识该block的状态*/</span></span><br><span class="line">        <span class="built_in">ssd_wblock_init</span>(ssd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note: free_wblock_q, defrag_wblock_q created after loading devices.</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cf_pool_int32_init</span>(&amp;ssd-&gt;fd_pool, MAX_POOL_FDS, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">cf_pool_int32_init</span>(&amp;ssd-&gt;fd_cache_pool, MAX_POOL_FDS, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列初始化：写队列，和free释放队列。队列里面存的指针。</span></span><br><span class="line">        ssd-&gt;swb_write_q = <span class="built_in">cf_queue_create</span>(<span class="built_in">sizeof</span>(<span class="type">void</span>*), <span class="literal">true</span>);</span><br><span class="line">        ssd-&gt;swb_free_q = <span class="built_in">cf_queue_create</span>(<span class="built_in">sizeof</span>(<span class="type">void</span>*), <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 该队列意义不明</span></span><br><span class="line">        ssd-&gt;post_write_q = <span class="built_in">cf_queue_create</span>(<span class="built_in">sizeof</span>(<span class="type">void</span>*),</span><br><span class="line">                ns-&gt;storage_commit_to_device);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读每个ssd的头block，初始化header结构。此处也能检查ssd有没有初始化(header部份非0)，获取ssd的数据元信息。</span></span><br><span class="line">    <span class="built_in">ssd_init_synchronous</span>(ssds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取ssd的设备元信息 */</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ssd_init_devices</span><span class="params">(as_namespace *ns, drv_ssds **ssds_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> ssds_size = <span class="built_in">sizeof</span>(drv_ssds) +</span><br><span class="line">            (ns-&gt;n_storage_devices * <span class="built_in">sizeof</span>(drv_ssd));</span><br><span class="line">    drv_ssds *ssds = <span class="built_in">cf_malloc</span>(ssds_size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ssds, <span class="number">0</span>, ssds_size);</span><br><span class="line">    ssds-&gt;n_ssds = (<span class="type">int</span>)ns-&gt;n_storage_devices;</span><br><span class="line">    ssds-&gt;ns = ns;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每一个ssd设备初始化，得到元信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; ns-&gt;n_storage_devices; i++) &#123;</span><br><span class="line">        drv_ssd *ssd = &amp;ssds-&gt;ssds[i];</span><br><span class="line"></span><br><span class="line">        ssd-&gt;name = ns-&gt;storage_devices[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认读写、直接io、强同步模式</span></span><br><span class="line">        ssd-&gt;open_flag = O_RDWR | O_DIRECT |</span><br><span class="line">                (ns-&gt;storage_disable_odsync ? <span class="number">0</span> : O_DSYNC);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> fd = <span class="built_in">open</span>(ssd-&gt;name, ssd-&gt;open_flag);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 确定真正能够写入的ssd大小，去必要的头部以及按块大小对齐</span></span><br><span class="line">        <span class="type">uint64_t</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">ioctl</span>(fd, BLKGETSIZE64, &amp;size); <span class="comment">// gets the number of byte</span></span><br><span class="line">        ssd-&gt;file_size = <span class="built_in">check_file_size</span>(ns, size, <span class="string">&quot;usable device&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断ssd设备最少一次读取出的数据大小</span></span><br><span class="line">        ssd-&gt;io_min_size = <span class="built_in">find_io_min_size</span>(fd, ssd-&gt;name);</span><br><span class="line">        <span class="comment">// 冷启动若设置为每一次启动都清空ssd数据，那么初始化header为全0</span></span><br><span class="line">        <span class="keyword">if</span> (ns-&gt;cold_start &amp;&amp; ns-&gt;storage_cold_start_empty) &#123;</span><br><span class="line">            <span class="built_in">ssd_empty_header</span>(fd, ssd-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">        ns-&gt;drives_size += ssd-&gt;file_size; <span class="comment">// increment total storage size</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *ssds_p = ssds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中上面涉及的wblock、以及读取ssd-header的初始化代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ssd_wblock_init</span><span class="params">(drv_ssd *ssd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> n_wblocks = (<span class="type">uint32_t</span>)(ssd-&gt;file_size / ssd-&gt;write_block_size);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cf_info</span>(AS_DRV_SSD, <span class="string">&quot;%s has %u wblocks of size %u&quot;</span>, ssd-&gt;name, n_wblocks,</span><br><span class="line">            ssd-&gt;write_block_size);</span><br><span class="line"></span><br><span class="line">    ssd-&gt;n_wblocks = n_wblocks;</span><br><span class="line">    ssd-&gt;wblock_state = <span class="built_in">cf_malloc</span>(n_wblocks * <span class="built_in">sizeof</span>(ssd_wblock_state));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化wblock_state，标识为free状态，inuse_sz为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; n_wblocks; i++) &#123;</span><br><span class="line">        ssd_wblock_state * p_wblock_state = &amp;ssd-&gt;wblock_state[i];</span><br><span class="line"></span><br><span class="line">        p_wblock_state-&gt;inuse_sz = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cf_mutex_init</span>(&amp;p_wblock_state-&gt;LOCK);</span><br><span class="line">        p_wblock_state-&gt;swb = <span class="literal">NULL</span>;</span><br><span class="line">        p_wblock_state-&gt;state = WBLOCK_STATE_FREE;</span><br><span class="line">        p_wblock_state-&gt;n_vac_dests = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ssd_init_synchronous</span><span class="params">(drv_ssds *ssds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> random = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (random == <span class="number">0</span>) &#123;</span><br><span class="line">        random = <span class="built_in">cf_get_rand64</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n_ssds = ssds-&gt;n_ssds;</span><br><span class="line">    as_namespace *ns = ssds-&gt;ns;</span><br><span class="line"></span><br><span class="line">    drv_header *headers[n_ssds];</span><br><span class="line">    <span class="type">int</span> first_used = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_ssds; i++) &#123;</span><br><span class="line">        drv_ssd *ssd = &amp;ssds-&gt;ssds[i];</span><br><span class="line">        <span class="comment">/* 从ssd的header块中读出元信息。包括</span></span><br><span class="line"><span class="comment">            1. 驱动版本号</span></span><br><span class="line"><span class="comment">            2. namespace名字</span></span><br><span class="line"><span class="comment">            3. write_block_size大小</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        headers[i] = <span class="built_in">ssd_read_header</span>(ssd);</span><br><span class="line">        <span class="comment">// 如果返回NULL，表示是一块全新的ssd</span></span><br><span class="line">        <span class="keyword">if</span> (! headers[i]) &#123;</span><br><span class="line">            headers[i] = <span class="built_in">ssd_init_header</span>(ns, ssd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (first_used &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            first_used = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果所有的ssd都是全新的，那么会走到这，初始化header，并写入ssd</span></span><br><span class="line">    <span class="keyword">if</span> (first_used &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ssds-&gt;generic = <span class="built_in">cf_valloc</span>(ROUND_UP_GENERIC);</span><br><span class="line">        <span class="built_in">memcpy</span>(ssds-&gt;generic, &amp;headers[<span class="number">0</span>]-&gt;generic, ROUND_UP_GENERIC);</span><br><span class="line"></span><br><span class="line">        ssds-&gt;generic-&gt;prefix.n_devices = n_ssds;</span><br><span class="line">        ssds-&gt;generic-&gt;prefix.random = random;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n_ssds; i++) &#123;</span><br><span class="line">            headers[i]-&gt;unique.device_id = (<span class="type">uint32_t</span>)i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ssd_adjust_versions</span>(ns, ssds-&gt;generic-&gt;pmeta);</span><br><span class="line">        <span class="built_in">ssd_flush_header</span>(ssds, headers);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        ssds-&gt;all_fresh = <span class="literal">true</span>; <span class="comment">// won&#x27;t need to scan devices</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将header数据复制到ssds-&gt;generic结构体中，做相应更新后，重新写回ssd的header块部分</span></span><br><span class="line">    ssds-&gt;generic = <span class="built_in">cf_valloc</span>(ROUND_UP_GENERIC);</span><br><span class="line">    <span class="built_in">memcpy</span>(ssds-&gt;generic, &amp;headers[first_used]-&gt;generic, ROUND_UP_GENERIC);</span><br><span class="line"></span><br><span class="line">    ssds-&gt;generic-&gt;prefix.n_devices = n_ssds; <span class="comment">// may have added fresh drives</span></span><br><span class="line">    ssds-&gt;generic-&gt;prefix.random = random;</span><br><span class="line">    ssds-&gt;generic-&gt;prefix.flags &amp;= ~DRV_HEADER_FLAG_TRUSTED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fresh_drive || n_ssds &lt; prefix_first-&gt;n_devices ||</span><br><span class="line">            (ns-&gt;dirty_restart &amp;&amp; non_commit_drive)) &#123;</span><br><span class="line">        <span class="built_in">ssd_adjust_versions</span>(ns, ssds-&gt;generic-&gt;pmeta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ssd_flush_header</span>(ssds, headers);</span><br><span class="line">    <span class="built_in">ssd_flush_final_cfg</span>(ns);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读出每个paritition的树id</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> pid = <span class="number">0</span>; pid &lt; AS_PARTITIONS; pid++) &#123;</span><br><span class="line">        drv_pmeta *pmeta = &amp;ssds-&gt;generic-&gt;pmeta[pid];</span><br><span class="line"></span><br><span class="line">        ssds-&gt;get_state_from_storage[pid] =</span><br><span class="line">                <span class="built_in">as_partition_version_has_data</span>(&amp;pmeta-&gt;version);</span><br><span class="line">        ns-&gt;partitions[pid].tree_id = pmeta-&gt;tree_id;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 冷启动时，对于每一个磁盘标识存在的分区，构造分区对于的索引树结构</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> pid = <span class="number">0</span>; pid &lt; AS_PARTITIONS; pid++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ssds-&gt;get_state_from_storage[pid]) &#123;</span><br><span class="line">            as_partition* p = &amp;ns-&gt;partitions[pid];</span><br><span class="line"></span><br><span class="line">            p-&gt;tree = <span class="built_in">as_index_tree_create</span>(&amp;ns-&gt;tree_shared, p-&gt;tree_id,</span><br><span class="line">                    as_partition_tree_done, (<span class="type">void</span>*)p);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">as_set_index_create_all</span>(ns, p-&gt;tree);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 冷启动时间</span></span><br><span class="line">    ns-&gt;cold_start_now = now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全盘扫描"><a href="#全盘扫描" class="headerlink" title="全盘扫描"></a>全盘扫描</h2><p>ssd全盘扫描函数,创建了一个新的线程<code>run_ssd_cold_start</code>去做该工作(实际上as有一个线程池，是从线程池里取一个线程做该工作)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">start_loading_records</span><span class="params">(drv_ssds *ssds, cf_queue *complete_q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    as_namespace *ns = ssds-&gt;ns;</span><br><span class="line"></span><br><span class="line">    ns-&gt;loading_records = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// p即complete_rc唯一的作用就是表示有多少块ssd(通过rc引用计数)，用于在所有ssd都load完毕后执行最后的收尾工作。</span></span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">cf_rc_alloc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ssds-&gt;n_ssds; i++) &#123;</span><br><span class="line">        <span class="built_in">cf_rc_reserve</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ssds-&gt;n_ssds; i++) &#123;</span><br><span class="line">        drv_ssd *ssd = &amp;ssds-&gt;ssds[i];</span><br><span class="line">        ssd_load_records_info *lri = <span class="built_in">cf_malloc</span>(<span class="built_in">sizeof</span>(ssd_load_records_info));</span><br><span class="line"></span><br><span class="line">        lri-&gt;ssds = ssds;</span><br><span class="line">        lri-&gt;ssd = ssd;</span><br><span class="line">        lri-&gt;complete_q = complete_q;</span><br><span class="line">        lri-&gt;complete_rc = p;</span><br><span class="line">        <span class="comment">// 创建临时线程（线程池中取）</span></span><br><span class="line">        <span class="built_in">cf_thread_create_transient</span>(run_ssd_cold_start, (<span class="type">void</span>*)lri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">run_ssd_cold_start</span><span class="params">(<span class="type">void</span> *udata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ssd_load_records_info *lri = (ssd_load_records_info*)udata;</span><br><span class="line">    drv_ssd *ssd = lri-&gt;ssd;</span><br><span class="line">    drv_ssds *ssds = lri-&gt;ssds;</span><br><span class="line">    cf_queue *complete_q = lri-&gt;complete_q;</span><br><span class="line">    <span class="type">void</span> *complete_rc = lri-&gt;complete_rc;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cf_free</span>(lri);</span><br><span class="line">    <span class="comment">// 核心入口</span></span><br><span class="line">    <span class="built_in">ssd_cold_start_sweep</span>(ssds, ssd);</span><br><span class="line">    <span class="comment">// 打印本次完整扫描的统计情况</span></span><br><span class="line">    <span class="built_in">cf_info</span>(AS_DRV_SSD, <span class="string">&quot;device %s: read complete: UNIQUE %lu (REPLACED %lu) (OLDER %lu) (EXPIRED %lu) (EVICTED %lu) records&quot;</span>,</span><br><span class="line">            ssd-&gt;name, ssd-&gt;record_add_unique_counter,</span><br><span class="line">            ssd-&gt;record_add_replace_counter, ssd-&gt;record_add_older_counter,</span><br><span class="line">            ssd-&gt;record_add_expired_counter, ssd-&gt;record_add_evicted_counter);</span><br><span class="line">    <span class="comment">// 通知主线程完成扫描</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cf_rc_release</span>(complete_rc) == <span class="number">0</span>) &#123;</span><br><span class="line">        as_namespace* ns = ssds-&gt;ns;</span><br><span class="line">        ns-&gt;loading_records = <span class="literal">false</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="type">void</span> *<span class="type">_t</span> = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">cf_queue_push</span>(complete_q, &amp;<span class="type">_t</span>);</span><br><span class="line">        <span class="built_in">cf_rc_free</span>(complete_rc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全盘扫描核心逻辑函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ssd_cold_start_sweep</span><span class="params">(drv_ssds *ssds, drv_ssd *ssd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> wblock_size = ssd-&gt;write_block_size;</span><br><span class="line">    <span class="type">uint8_t</span> *buf = <span class="built_in">cf_valloc</span>(wblock_size);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *read_ssd_name = ssd-&gt;name;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">ssd_fd_get</span>(ssd);</span><br><span class="line">    <span class="type">int</span> write_fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop over all wblocks, unless we encounter 10 contiguous unused wblocks.</span></span><br><span class="line"></span><br><span class="line">    ssd-&gt;sweep_wblock_id = ssd-&gt;first_wblock_id;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> file_offset = DRV_HEADER_SIZE;</span><br><span class="line">    <span class="type">uint32_t</span> n_unused_wblocks = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (file_offset &lt; ssd-&gt;file_size &amp;&amp; n_unused_wblocks &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">pread_all</span>(fd, buf, wblock_size, (<span class="type">off_t</span>)file_offset)</span><br><span class="line"></span><br><span class="line">        <span class="type">uint32_t</span> indent = <span class="number">0</span>; <span class="comment">// current offset within wblock, in bytes</span></span><br><span class="line">        <span class="keyword">while</span> (indent &lt; wblock_size) &#123;</span><br><span class="line">            as_flat_record *flat = (as_flat_record*)&amp;buf[indent];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Look for record magic.</span></span><br><span class="line">            <span class="keyword">if</span> (flat-&gt;magic != AS_FLAT_MAGIC) &#123;</span><br><span class="line">                <span class="comment">// Should always find a record at beginning of used wblock. if</span></span><br><span class="line">                <span class="comment">// not, we&#x27;ve likely encountered the unused part of the device.</span></span><br><span class="line">                <span class="keyword">if</span> (indent == <span class="number">0</span>) &#123;</span><br><span class="line">                    n_unused_wblocks++;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// try next wblock</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else - nothing more in this wblock, but keep looking for</span></span><br><span class="line">                <span class="comment">// magic - necessary if we want to be able to increase</span></span><br><span class="line">                <span class="comment">// write-block-size across restarts.</span></span><br><span class="line"></span><br><span class="line">                indent += RBLOCK_SIZE;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// try next rblock</span></span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// N_RBLOCKS_TO_SIZE为16bytes</span></span><br><span class="line">            <span class="type">uint32_t</span> record_size = <span class="built_in">N_RBLOCKS_TO_SIZE</span>(flat-&gt;n_rblocks);</span><br><span class="line">            <span class="type">uint32_t</span> next_indent = indent + record_size;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Found a record - try to add it to the index.</span></span><br><span class="line">            <span class="built_in">ssd_cold_start_add_record</span>(ssds, ssd, flat,</span><br><span class="line">                    <span class="built_in">OFFSET_TO_RBLOCK_ID</span>(file_offset + indent), record_size);</span><br><span class="line"></span><br><span class="line">            indent = next_indent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        file_offset += wblock_size;</span><br><span class="line">        ssd-&gt;sweep_wblock_id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ssd-&gt;pristine_wblock_id = ssd-&gt;sweep_wblock_id - n_unused_wblocks;</span><br><span class="line"></span><br><span class="line">    ssd-&gt;sweep_wblock_id = (<span class="type">uint32_t</span>)(ssd-&gt;file_size / wblock_size);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">cf_free</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于每一个record，解析并增加内存索引的函数如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add a record just read from drive to the index, if all is well.</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ssd_cold_start_add_record</span><span class="params">(drv_ssds* ssds, drv_ssd* ssd,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> as_flat_record* flat, <span class="type">uint64_t</span> rblock_id, <span class="type">uint32_t</span> record_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用hash值算出partition-id</span></span><br><span class="line">    <span class="type">uint32_t</span> pid = <span class="built_in">as_partition_getid</span>(&amp;flat-&gt;keyd);</span><br><span class="line">    <span class="comment">// 在ssd的header中指示了哪些partition是本节点关心的，不关心的直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (! ssds-&gt;get_state_from_storage[pid]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    as_namespace* ns = ssds-&gt;ns;</span><br><span class="line">    as_partition* p_partition = &amp;ns-&gt;partitions[pid];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析额外的meta信息，如key值、set名、bins数量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span>* end = (<span class="type">const</span> <span class="type">uint8_t</span>*)flat + record_size - END_MARK_SZ;</span><br><span class="line">    as_flat_opt_meta opt_meta = &#123; &#123; <span class="number">0</span> &#125; &#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span>* p_read = <span class="built_in">as_flat_unpack_record_meta</span>(flat, end, &amp;opt_meta);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span>* cb_end = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 校验每一个bin的结构是否正确，得出末尾地址指针</span></span><br><span class="line">    <span class="type">const</span> <span class="type">uint8_t</span>* exact_end = <span class="built_in">as_flat_check_packed_bins</span>(p_read, end,</span><br><span class="line">            opt_meta.n_bins);</span><br><span class="line">    <span class="comment">// 校验末尾值是否正确，防意外bug(用key的哈希值计算出的一个值)</span></span><br><span class="line">    <span class="keyword">if</span> (! <span class="built_in">drv_check_end_mark</span>(cb_end == <span class="literal">NULL</span> ? exact_end : cb_end, flat)) &#123;</span><br><span class="line">        <span class="built_in">cf_warning</span>(AS_DRV_SSD, <span class="string">&quot;bad end marker for %pD&quot;</span>, &amp;flat-&gt;keyd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get/create the record from/in the appropriate index tree.</span></span><br><span class="line">    as_index_ref r_ref;</span><br><span class="line">    <span class="type">int</span> rv = <span class="built_in">as_record_get_create</span>(p_partition-&gt;tree, &amp;flat-&gt;keyd, &amp;r_ref, ns);</span><br><span class="line">    <span class="type">bool</span> is_create = rv == <span class="number">1</span>;</span><br><span class="line">    as_index* r = r_ref.r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是新的索引节点，而又找到了该key，需要判断新旧关系，决定哪个留下来。</span></span><br><span class="line">    <span class="keyword">if</span> (! is_create) &#123;</span><br><span class="line">        <span class="comment">// Record already existed. Ignore this one if existing record is newer.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">prefer_existing_record</span>(ns, flat, opt_meta.void_time, r)) &#123;</span><br><span class="line">            <span class="comment">// 如果当前记录更老，代码会进来，销毁当前这个record</span></span><br><span class="line">            <span class="built_in">ssd_cold_start_adjust_cenotaph</span>(ns, flat, opt_meta.void_time, r);</span><br><span class="line">            <span class="built_in">as_record_done</span>(&amp;r_ref, ns);</span><br><span class="line">            ssd-&gt;record_add_older_counter++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The record we&#x27;re now reading is the latest version (so far) ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过期删除</span></span><br><span class="line">    <span class="keyword">if</span> (opt_meta.void_time != <span class="number">0</span> &amp;&amp; ns-&gt;cold_start_now &gt; opt_meta.void_time) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! is_create) &#123;</span><br><span class="line">            <span class="comment">// Note - no sindex to adjust.</span></span><br><span class="line">            <span class="built_in">as_set_index_delete_live</span>(ns, p_partition-&gt;tree, r, r_ref.r_h);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">as_index_delete</span>(p_partition-&gt;tree, &amp;flat-&gt;keyd);</span><br><span class="line">        <span class="built_in">as_record_done</span>(&amp;r_ref, ns);</span><br><span class="line">        ssd-&gt;record_add_expired_counter++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 淘汰删除</span></span><br><span class="line">    <span class="keyword">if</span> (opt_meta.void_time != <span class="number">0</span> &amp;&amp; ns-&gt;evict_void_time &gt; opt_meta.void_time &amp;&amp;</span><br><span class="line">            <span class="built_in">drv_is_set_evictable</span>(ns, &amp;opt_meta)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! is_create) &#123;</span><br><span class="line">            <span class="comment">// Note - no sindex to adjust.</span></span><br><span class="line">            <span class="built_in">as_set_index_delete_live</span>(ns, p_partition-&gt;tree, r, r_ref.r_h);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">as_index_delete</span>(p_partition-&gt;tree, &amp;flat-&gt;keyd);</span><br><span class="line">        <span class="built_in">as_record_done</span>(&amp;r_ref, ns);</span><br><span class="line">        ssd-&gt;record_add_evicted_counter++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到此处，该record就完全保留了，也已经分配了索引节点</span></span><br><span class="line">    <span class="built_in">drv_apply_opt_meta</span>(r, ns, &amp;opt_meta);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set/reset the record&#x27;s last-update-time, generation, and void-time.</span></span><br><span class="line">    r-&gt;last_update_time = flat-&gt;last_update_time;</span><br><span class="line">    r-&gt;generation = flat-&gt;generation;</span><br><span class="line">    r-&gt;void_time = opt_meta.void_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update maximum void-time.</span></span><br><span class="line">    <span class="built_in">as_setmax_uint32</span>(&amp;p_partition-&gt;max_void_time, r-&gt;void_time);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_create) &#123;</span><br><span class="line">        ssd-&gt;record_add_unique_counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果之前已经读到了该key，但是现在这个record更新，会将之前的record换个位置。相当于把之前的所有rblock释放掉，找一块新的地方放。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">STORAGE_RBLOCK_IS_VALID</span>(r-&gt;rblock_id)) &#123;</span><br><span class="line">        <span class="comment">// Replacing an existing record, undo its previous storage accounting.</span></span><br><span class="line">        <span class="built_in">ssd_block_free</span>(&amp;ssds-&gt;ssds[r-&gt;file_id], r-&gt;rblock_id, r-&gt;n_rblocks,</span><br><span class="line">                <span class="string">&quot;record-add&quot;</span>);</span><br><span class="line">        ssd-&gt;record_add_replace_counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cf_warning</span>(AS_DRV_SSD, <span class="string">&quot;replacing record with invalid rblock-id&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里插入了索引树</span></span><br><span class="line">    <span class="built_in">ssd_cold_start_transition_record</span>(ns, flat, &amp;opt_meta, p_partition-&gt;tree,</span><br><span class="line">            &amp;r_ref, is_create);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> wblock_id = <span class="built_in">RBLOCK_ID_TO_WBLOCK_ID</span>(ssd, rblock_id);</span><br><span class="line">    <span class="comment">// 维护wblock_state结构</span></span><br><span class="line">    ssd-&gt;inuse_size += record_size;</span><br><span class="line">    ssd-&gt;wblock_state[wblock_id].inuse_sz += record_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set/reset the record&#x27;s storage information.</span></span><br><span class="line">    r-&gt;file_id = ssd-&gt;file_id;</span><br><span class="line">    r-&gt;rblock_id = rblock_id;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">as_namespace_adjust_set_data_used_bytes</span>(ns, <span class="built_in">as_index_get_set_id</span>(r),</span><br><span class="line">            <span class="built_in">DELTA_N_RBLOCKS_TO_SIZE</span>(flat-&gt;n_rblocks, r-&gt;n_rblocks));</span><br><span class="line"></span><br><span class="line">    r-&gt;n_rblocks = flat-&gt;n_rblocks;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="built_in">as_record_done</span>(&amp;r_ref, ns);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放一串rblock的代码操作如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ssd_block_free</span>(&amp;ssds-&gt;ssds[r-&gt;file_id], r-&gt;rblock_id, r-&gt;n_rblocks,</span><br><span class="line">                <span class="string">&quot;record-add&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  值得注意的是，该函数大多数情况下仅仅只是维护了wblock_state这个结构，将inuse_sz减少,没有真正修改任何ssd里面的数据。</span></span><br><span class="line"><span class="comment">    当inuse_sz=0时，会将该wblock_id放到free_q来回收。当inuse_sz小于碎片整理阈值（默认50%）时,会将其传给defrag_q用于碎片整理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ssd_block_free</span><span class="params">(drv_ssd *ssd, <span class="type">uint64_t</span> rblock_id, <span class="type">uint32_t</span> n_rblocks, <span class="type">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Determine which wblock we&#x27;re reducing used size in.</span></span><br><span class="line">    <span class="type">uint64_t</span> start_offset = <span class="built_in">RBLOCK_ID_TO_OFFSET</span>(rblock_id);</span><br><span class="line">    <span class="type">uint32_t</span> size = <span class="built_in">N_RBLOCKS_TO_SIZE</span>(n_rblocks);</span><br><span class="line">    <span class="type">uint32_t</span> wblock_id = <span class="built_in">OFFSET_TO_WBLOCK_ID</span>(ssd, start_offset);</span><br><span class="line">    <span class="type">uint32_t</span> end_wblock_id = <span class="built_in">OFFSET_TO_WBLOCK_ID</span>(ssd, start_offset + size - <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">as_add_uint64</span>(&amp;ssd-&gt;inuse_size, -(<span class="type">int64_t</span>)size);</span><br><span class="line"></span><br><span class="line">    ssd_wblock_state *p_wblock_state = &amp;ssd-&gt;wblock_state[wblock_id];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cf_mutex_lock</span>(&amp;p_wblock_state-&gt;LOCK);</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> resulting_inuse_sz =</span><br><span class="line">            (<span class="type">int32_t</span>)<span class="built_in">as_aaf_uint32</span>(&amp;p_wblock_state-&gt;inuse_sz, -(<span class="type">int32_t</span>)size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p_wblock_state-&gt;state == WBLOCK_STATE_USED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resulting_inuse_sz == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">as_incr_uint64</span>(&amp;ssd-&gt;n_wblock_direct_frees);</span><br><span class="line">            <span class="built_in">push_wblock_to_free_q</span>(ssd, wblock_id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (resulting_inuse_sz &lt; ssd-&gt;ns-&gt;defrag_lwm_size) &#123;</span><br><span class="line">            <span class="built_in">push_wblock_to_defrag_q</span>(ssd, wblock_id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p_wblock_state-&gt;state == WBLOCK_STATE_EMPTYING) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resulting_inuse_sz == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">push_wblock_to_free_q</span>(ssd, wblock_id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cf_mutex_unlock</span>(&amp;p_wblock_state-&gt;LOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于完全清空的wblock，直接回收其id，并标记其wblock_state为已释放。意味着需要分配一个wblock的时候，可以直接从<code>ssd-&gt;free_wblock_q</code>取，然后覆盖写入，减少了擦除操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Put a wblock on the free queue for reuse.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">push_wblock_to_free_q</span><span class="params">(drv_ssd *ssd, <span class="type">uint32_t</span> wblock_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 全盘扫描时，还没初始化该队列。因全盘扫描一结束便会自己手动扫一遍block_state</span></span><br><span class="line">    <span class="keyword">if</span> (ssd-&gt;free_wblock_q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ssd-&gt;wblock_state[wblock_id].state = WBLOCK_STATE_FREE;</span><br><span class="line">    <span class="built_in">cf_queue_push</span>(ssd-&gt;free_wblock_q, &amp;wblock_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于碎片率已经达到高水位的块，传递给碎片整理程序处理。会将其搬空</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Put a wblock on the defrag queue.</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">push_wblock_to_defrag_q</span><span class="params">(drv_ssd *ssd, <span class="type">uint32_t</span> wblock_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ssd-&gt;defrag_wblock_q) &#123; <span class="comment">// null until devices are loaded at startup</span></span><br><span class="line">        ssd-&gt;wblock_state[wblock_id].state = WBLOCK_STATE_DEFRAG;</span><br><span class="line">        <span class="built_in">cf_queue_push</span>(ssd-&gt;defrag_wblock_q, &amp;wblock_id);</span><br><span class="line">        <span class="built_in">as_incr_uint64</span>(&amp;ssd-&gt;n_defrag_wblock_reads);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="垃圾回收与碎片整理"><a href="#垃圾回收与碎片整理" class="headerlink" title="垃圾回收与碎片整理"></a>垃圾回收与碎片整理</h2><p>在全盘扫描完成后，初始化填充了<code>wblock_state[]</code>结构体，得知了每一个wblock的磁盘使用量。此时会立马进行一次扫描所有该结构体的操作，创建相关free队列(垃圾块回收)和defrag队列(碎片整理)。将相关的wblock放置于相应的队列中。</p>
<p>对于free队列，逻辑很简单，在需要分配wblock时，直接复用该块即可。</p>
<p>对于defrag队列，则需要碎片整理，将该块的数据全部搬运走，直到清0，进入free队列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全盘扫描后紧接的下一个总入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">as_storage_activate_ssd</span><span class="params">(as_namespace *ns)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    drv_ssds *ssds = (drv_ssds*)ns-&gt;storage_private;</span><br><span class="line">    <span class="comment">// 统计与初始化队列</span></span><br><span class="line">    <span class="built_in">ssd_load_wblock_queues</span>(ssds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启各个ssd相关线程</span></span><br><span class="line">    <span class="comment">//maintenance线程仅仅只是定时打印ssd读写与碎片整理等统计信息到日志中</span></span><br><span class="line">    <span class="built_in">ssd_start_maintenance_threads</span>(ssds);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">ssd_start_write_threads</span>(ssds);</span><br><span class="line">    <span class="built_in">ssd_start_defrag_threads</span>(ssds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ssd_load_wblock_queues -&gt; run_load_queues</span></span><br><span class="line"><span class="function"><span class="type">void</span>*</span></span><br><span class="line"><span class="function"><span class="title">run_load_queues</span><span class="params">(<span class="type">void</span> *pv_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    drv_ssd *ssd = (drv_ssd*)pv_data;</span><br><span class="line">    <span class="comment">// 创建队列</span></span><br><span class="line">    ssd-&gt;free_wblock_q = <span class="built_in">cf_queue_create</span>(<span class="built_in">sizeof</span>(<span class="type">uint32_t</span>), <span class="literal">true</span>);</span><br><span class="line">    ssd-&gt;defrag_wblock_q = <span class="built_in">cf_queue_create</span>(<span class="built_in">sizeof</span>(<span class="type">uint32_t</span>), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    as_namespace *ns = ssd-&gt;ns;</span><br><span class="line">    <span class="type">uint32_t</span> lwm_pct = ns-&gt;storage_defrag_lwm_pct;</span><br><span class="line">    <span class="type">uint32_t</span> lwm_size = ns-&gt;defrag_lwm_size;</span><br><span class="line">    <span class="comment">// 每一个百分比一个结构体，本质上是为了后续日志打印。</span></span><br><span class="line">    defrag_pen pens[lwm_pct];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> n = <span class="number">0</span>; n &lt; lwm_pct; n++) &#123;</span><br><span class="line">        <span class="built_in">defrag_pen_init</span>(&amp;pens[n]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> first_id = ssd-&gt;first_wblock_id;</span><br><span class="line">    <span class="type">uint32_t</span> end_id = ssd-&gt;pristine_wblock_id;</span><br><span class="line">    <span class="comment">// 遍历全部的wblock_state结构，进行碎片整理或垃圾回收</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> wblock_id = first_id; wblock_id &lt; end_id; wblock_id++) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> inuse_sz = ssd-&gt;wblock_state[wblock_id].inuse_sz;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inuse_sz == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Faster than using push_wblock_to_free_q() here...</span></span><br><span class="line">            <span class="built_in">cf_queue_push</span>(ssd-&gt;free_wblock_q, &amp;wblock_id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (inuse_sz &lt; lwm_size) &#123;</span><br><span class="line">            <span class="built_in">defrag_pen_add</span>(&amp;pens[(inuse_sz * lwm_pct) / lwm_size], wblock_id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ssd-&gt;wblock_state[wblock_id].state = WBLOCK_STATE_USED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">defrag_pens_dump</span>(pens, lwm_pct, ssd-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> n = <span class="number">0</span>; n &lt; lwm_pct; n++) &#123;</span><br><span class="line">        <span class="comment">// 该步将pens的所有wblock_id传送到defrag_queue中</span></span><br><span class="line">        <span class="built_in">defrag_pen_transfer</span>(&amp;pens[n], ssd);</span><br><span class="line">        <span class="built_in">defrag_pen_destroy</span>(&amp;pens[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到当前碎片整理队列的队列长度</span></span><br><span class="line">    ssd-&gt;n_defrag_wblock_reads = (<span class="type">uint64_t</span>)<span class="built_in">cf_queue_sz</span>(ssd-&gt;defrag_wblock_q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点关注defrag线程做的工作，如何整理碎片率高的wblock。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ssd_start_defrag_threads(ssds) -&gt; run_defrag</span></span><br><span class="line"><span class="function"><span class="type">void</span>*</span></span><br><span class="line"><span class="function"><span class="title">run_defrag</span><span class="params">(<span class="type">void</span> *pv_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    drv_ssd *ssd = (drv_ssd*)pv_data;</span><br><span class="line">    as_namespace *ns = ssd-&gt;ns;</span><br><span class="line">    <span class="type">uint32_t</span> wblock_id;</span><br><span class="line">    <span class="type">uint8_t</span> *read_buf = <span class="built_in">cf_valloc</span>(ssd-&gt;write_block_size);</span><br><span class="line">    <span class="comment">// 省略了sleep的代码（如刷盘压力大时会sleep）</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//需整理的wblock队列中取出一个id来整理</span></span><br><span class="line">        <span class="built_in">cf_queue_pop</span>(ssd-&gt;defrag_wblock_q, &amp;wblock_id, CF_QUEUE_FOREVER);</span><br><span class="line">        <span class="built_in">ssd_defrag_wblock</span>(ssd, wblock_id, read_buf);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对整个wblock从ssd中读出来，遍历所有record，迁移走</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">ssd_defrag_wblock</span><span class="params">(drv_ssd *ssd, <span class="type">uint32_t</span> wblock_id, <span class="type">uint8_t</span> *read_buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> record_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ssd_wblock_state* p_wblock_state = &amp;ssd-&gt;wblock_state[wblock_id];</span><br><span class="line">    <span class="comment">// 这个assert表明了当前整理块的迁移目的块必须为0</span></span><br><span class="line">    <span class="built_in">cf_assert</span>(p_wblock_state-&gt;n_vac_dests == <span class="number">0</span>, AS_DRV_SSD,</span><br><span class="line">            <span class="string">&quot;n-vacations not 0 beginning defrag wblock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure this can&#x27;t decrement to 0 while defragging this wblock.</span></span><br><span class="line">    p_wblock_state-&gt;n_vac_dests = <span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">ssd_fd_get</span>(ssd);</span><br><span class="line">    <span class="type">uint64_t</span> file_offset = <span class="built_in">WBLOCK_ID_TO_OFFSET</span>(ssd, wblock_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将该wblock全部读出来到read_buf中</span></span><br><span class="line">    <span class="built_in">pread_all</span>(fd, read_buf, ssd-&gt;write_block_size, (<span class="type">off_t</span>)file_offset)</span><br><span class="line">    <span class="built_in">ssd_fd_put</span>(ssd, fd);</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">uint32_t</span> indent = <span class="number">0</span>; <span class="comment">// current offset within the wblock, in bytes</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始逐个record的解析该wblock</span></span><br><span class="line">    <span class="keyword">while</span> (indent &lt; ssd-&gt;write_block_size &amp;&amp;</span><br><span class="line">            <span class="built_in">as_load_uint32</span>(&amp;p_wblock_state-&gt;inuse_sz) != <span class="number">0</span>) &#123;</span><br><span class="line">        as_flat_record *flat = (as_flat_record*)&amp;read_buf[indent];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (! prefetch) &#123;</span><br><span class="line">            <span class="built_in">ssd_decrypt</span>(ssd, file_offset + indent, flat);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flat-&gt;magic != AS_FLAT_MAGIC) &#123;</span><br><span class="line">            <span class="comment">// First block must have magic.</span></span><br><span class="line">            <span class="keyword">if</span> (indent == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">cf_warning</span>(AS_DRV_SSD, <span class="string">&quot;%s: no magic at beginning of used wblock %d&quot;</span>,</span><br><span class="line">                        ssd-&gt;name, wblock_id);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Later blocks may have no magic, just skip to next block.</span></span><br><span class="line">            indent += RBLOCK_SIZE;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">uint32_t</span> record_size = <span class="built_in">N_RBLOCKS_TO_SIZE</span>(flat-&gt;n_rblocks);</span><br><span class="line">        <span class="type">uint32_t</span> next_indent = indent + record_size;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到此处解析出了一个record，将其迁移走</span></span><br><span class="line">        <span class="type">int</span> rv = <span class="built_in">ssd_record_defrag</span>(ssd, wblock_id, flat,</span><br><span class="line">                <span class="built_in">OFFSET_TO_RBLOCK_ID</span>(file_offset + indent));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rv == <span class="number">0</span>) &#123;</span><br><span class="line">            record_count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        indent = next_indent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Finished:</span><br><span class="line">    <span class="comment">//该块已经被完全清空，释放关联的wblock</span></span><br><span class="line">    <span class="built_in">ssd_release_vacated_wblock</span>(ssd, wblock_id, p_wblock_state);</span><br><span class="line">    <span class="keyword">return</span> record_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于单条record迁移走的逻辑如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ssd_record_defrag</span><span class="params">(drv_ssd *ssd, <span class="type">uint32_t</span> wblock_id, as_flat_record *flat,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint64_t</span> rblock_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">int</span> rv;</span><br><span class="line">    as_index_ref r_ref;</span><br><span class="line">    <span class="comment">// 从索引树中找到该索引记录，hold锁</span></span><br><span class="line">    <span class="type">bool</span> found = <span class="number">0</span> == <span class="built_in">as_record_get</span>(rsv.tree, &amp;flat-&gt;keyd, &amp;r_ref);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        as_index *r = r_ref.r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r-&gt;file_id == ssd-&gt;file_id &amp;&amp; r-&gt;rblock_id == rblock_id) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="built_in">defrag_move_record</span>(ssd, wblock_id, flat, r);</span><br><span class="line">            rv = <span class="number">0</span>; <span class="comment">// record was in index tree and current - moved it</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            rv = <span class="number">-1</span>; <span class="comment">// record was in index tree - presumably was overwritten</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        <span class="built_in">as_record_done</span>(&amp;r_ref, ns);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        rv = <span class="number">-2</span>; <span class="comment">// 索引树中找不到，基本是被删除了</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">defrag_move_record</span><span class="params">(drv_ssd *src_ssd, <span class="type">uint32_t</span> src_wblock_id,</span></span></span><br><span class="line"><span class="params"><span class="function">        as_flat_record *flat, as_index *r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> old_rblock_id = r-&gt;rblock_id;</span><br><span class="line">    <span class="type">uint32_t</span> old_n_rblocks = r-&gt;n_rblocks;</span><br><span class="line"></span><br><span class="line">    drv_ssds *ssds = (drv_ssds*)src_ssd-&gt;ns-&gt;storage_private;</span><br><span class="line"></span><br><span class="line">    drv_ssd *ssd = &amp;ssds-&gt;ssds[<span class="built_in">ssd_get_file_id</span>(ssds, &amp;flat-&gt;keyd)];</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> ssd_n_rblocks = flat-&gt;n_rblocks;</span><br><span class="line">    <span class="type">uint32_t</span> write_size = <span class="built_in">N_RBLOCKS_TO_SIZE</span>(ssd_n_rblocks);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cf_mutex_lock</span>(&amp;ssd-&gt;defrag_lock);</span><br><span class="line">    <span class="comment">//这一步需要重点关注。一般ssd上会挂着当前碎片迁往的swb，如果该swb写满了可能就会为空。</span></span><br><span class="line">    <span class="comment">//那么会重新分配一个全新的wblock（从ssd-&gt;free_wblock_q中取或直接拿新的），然后关联本swb</span></span><br><span class="line">    ssd_write_buf *swb = ssd-&gt;defrag_swb;</span><br><span class="line">    <span class="keyword">if</span> (! swb) &#123;</span><br><span class="line">        swb = <span class="built_in">swb_get</span>(ssd, <span class="literal">true</span>);</span><br><span class="line">        ssd-&gt;defrag_swb = swb;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (! swb) &#123;</span><br><span class="line">            <span class="built_in">cf_warning</span>(AS_DRV_SSD, <span class="string">&quot;defrag_move_record: couldn&#x27;t get swb&quot;</span>);</span><br><span class="line">            <span class="built_in">cf_mutex_unlock</span>(&amp;ssd-&gt;defrag_lock);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就是当前ssd挂着的defrag-&gt;swb写满的逻辑，会换一块新的wblock来迁</span></span><br><span class="line">    <span class="keyword">if</span> (write_size &gt; ssd-&gt;write_block_size - swb-&gt;pos) &#123;</span><br><span class="line">        <span class="comment">// 满了，往write_q里放，刷盘线程（就run_write线程）会去刷盘</span></span><br><span class="line">        <span class="built_in">push_wblock_to_write_q</span>(ssd, swb);</span><br><span class="line">        <span class="built_in">as_incr_uint64</span>(&amp;ssd-&gt;n_defrag_wblock_writes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the new buffer.</span></span><br><span class="line">        <span class="keyword">while</span> ((swb = <span class="built_in">swb_get</span>(ssd, <span class="literal">true</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ssd-&gt;defrag_swb = swb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(swb-&gt;buf + swb-&gt;pos, (<span class="type">const</span> <span class="type">uint8_t</span>*)flat, write_size);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> write_offset = <span class="built_in">WBLOCK_ID_TO_OFFSET</span>(ssd, swb-&gt;wblock_id) + swb-&gt;pos;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ssd_encrypt</span>(ssd, write_offset, (as_flat_record *)(swb-&gt;buf + swb-&gt;pos));</span><br><span class="line"></span><br><span class="line">    r-&gt;file_id = ssd-&gt;file_id;</span><br><span class="line">    r-&gt;rblock_id = <span class="built_in">OFFSET_TO_RBLOCK_ID</span>(write_offset);</span><br><span class="line">    r-&gt;n_rblocks = ssd_n_rblocks;</span><br><span class="line"></span><br><span class="line">    swb-&gt;pos += write_size;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">as_add_uint64</span>(&amp;ssd-&gt;inuse_size, (<span class="type">int64_t</span>)write_size);</span><br><span class="line">    <span class="built_in">as_add_uint32</span>(&amp;ssd-&gt;wblock_state[swb-&gt;wblock_id].inuse_sz,</span><br><span class="line">            (<span class="type">int32_t</span>)write_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录一下当前wblock迁往的目标wblock列表</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">swb_add_unique_vacated_wblock</span>(swb, src_ssd-&gt;file_id, src_wblock_id)) &#123;</span><br><span class="line">        ssd_wblock_state* p_wblock_state =</span><br><span class="line">                &amp;src_ssd-&gt;wblock_state[src_wblock_id];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">as_incr_uint32</span>(&amp;p_wblock_state-&gt;n_vac_dests);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cf_mutex_unlock</span>(&amp;ssd-&gt;defrag_lock);</span><br><span class="line">    <span class="comment">// 这个函数前面阐述过，只是简单维护一个inuse变量，没有io操作</span></span><br><span class="line">    <span class="built_in">ssd_block_free</span>(src_ssd, old_rblock_id, old_n_rblocks, <span class="string">&quot;defrag-write&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取一块可用的wblock的代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ssd_write_buf *</span></span><br><span class="line"><span class="function"><span class="title">swb_get</span><span class="params">(drv_ssd *ssd, <span class="type">bool</span> use_reserve)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ssd_write_buf *swb;</span><br><span class="line">    <span class="comment">// 队列中拿缓存，或者分配一个</span></span><br><span class="line">    <span class="keyword">if</span> (CF_QUEUE_OK != <span class="built_in">cf_queue_pop</span>(ssd-&gt;swb_free_q, &amp;swb, CF_QUEUE_NOWAIT)) &#123;</span><br><span class="line">        swb = <span class="built_in">swb_create</span>(ssd);</span><br><span class="line">        swb-&gt;rc = <span class="number">0</span>;</span><br><span class="line">        swb-&gt;n_writers = <span class="number">0</span>;</span><br><span class="line">        swb-&gt;dirty = <span class="literal">false</span>;</span><br><span class="line">        swb-&gt;use_post_write_q = <span class="literal">false</span>;</span><br><span class="line">        swb-&gt;flush_pos = <span class="number">0</span>;</span><br><span class="line">        swb-&gt;ssd = ssd;</span><br><span class="line">        swb-&gt;wblock_id = STORAGE_INVALID_WBLOCK;</span><br><span class="line">        swb-&gt;pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从free队列中拿，或者直接拿新的，即pristine_wblock_id+1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cf_queue_pop</span>(ssd-&gt;free_wblock_q, &amp;swb-&gt;wblock_id, CF_QUEUE_NOWAIT) !=</span><br><span class="line">            CF_QUEUE_OK &amp;&amp; ! <span class="built_in">pop_pristine_wblock_id</span>(ssd, &amp;swb-&gt;wblock_id)) &#123;</span><br><span class="line">        <span class="built_in">cf_queue_push</span>(ssd-&gt;swb_free_q, &amp;swb);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    swb-&gt;rc = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ssd_wblock_state* p_wblock_state = &amp;ssd-&gt;wblock_state[swb-&gt;wblock_id];</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> inuse_sz = <span class="built_in">as_load_uint32</span>(&amp;p_wblock_state-&gt;inuse_sz);</span><br><span class="line">    ...</span><br><span class="line">    p_wblock_state-&gt;swb = swb;</span><br><span class="line">    p_wblock_state-&gt;state = WBLOCK_STATE_RESERVED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> swb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ssd-write刷盘线程，不断从swb_write_q中取去待刷盘的buffer进行刷盘操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ssd_start_write_threads(ssds) -&gt; run_write()</span></span><br><span class="line"><span class="comment">// 一个需要关注的点是：刷盘完成才是块释放的信号，一个swb刷盘后，才表示之前碎片的块可以释放重用了，或者当前块可以状态改变为inuse了。</span></span><br><span class="line"><span class="function"><span class="type">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">run_write</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    drv_ssd *ssd = (drv_ssd*)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ssd-&gt;running || <span class="built_in">cf_queue_sz</span>(ssd-&gt;swb_write_q) != <span class="number">0</span>) &#123;</span><br><span class="line">        ssd_write_buf *swb;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (CF_QUEUE_OK != <span class="built_in">cf_queue_pop</span>(ssd-&gt;swb_write_q, &amp;swb, <span class="number">100</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Flush to the device.</span></span><br><span class="line">        <span class="built_in">ssd_flush_swb</span>(ssd, swb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this swb was a defrag destination, release the sources.</span></span><br><span class="line">        <span class="comment">// 该swb可能是多个wblock的目标迁移块，因此维护好相应的源wblock的元数据信息</span></span><br><span class="line">        <span class="built_in">swb_release_all_vacated_wblocks</span>(swb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据当前的swb状态，决定其wblock_state，是需要碎片整理还是直接标记为inuse</span></span><br><span class="line">        <span class="built_in">ssd_post_write</span>(ssd, swb);</span><br><span class="line">        <span class="comment">// 需要刷盘的wblock块数减1</span></span><br><span class="line">        <span class="built_in">as_decr_uint32</span>(&amp;ssd-&gt;ns-&gt;n_wblocks_to_flush);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="comment">// infinite event loop waiting for block to write</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个刷盘的swb结构，对应于一个wblock，待flush的swb的pos记录了有效数据的末尾地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ssd_flush_swb</span><span class="params">(drv_ssd *ssd, ssd_write_buf *swb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Clean the end of the buffer before flushing.</span></span><br><span class="line">    <span class="comment">// 无效数据清0</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;swb-&gt;buf[swb-&gt;pos], <span class="number">0</span>, ssd-&gt;write_block_size - swb-&gt;pos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for all writers to finish.</span></span><br><span class="line">    <span class="comment">// 如果该swb还有线程在写操作，则等待清0再刷盘</span></span><br><span class="line">    <span class="keyword">while</span> (swb-&gt;n_writers != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">as_arch_pause</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">as_fence_acq</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">ssd_fd_get</span>(ssd);</span><br><span class="line">    <span class="comment">// 根据wblock_id计算出ssd的offset</span></span><br><span class="line">    <span class="type">off_t</span> write_offset = (<span class="type">off_t</span>)<span class="built_in">WBLOCK_ID_TO_OFFSET</span>(ssd, swb-&gt;wblock_id);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> start_ns = ssd-&gt;ns-&gt;storage_benchmarks_enabled ? <span class="built_in">cf_getns</span>() : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 可以看到是整个wblock写入</span></span><br><span class="line">    <span class="built_in">pwrite_all</span>(fd, swb-&gt;buf, ssd-&gt;write_block_size, write_offset)</span><br><span class="line">    <span class="built_in">ssd_fd_put</span>(ssd, fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刷盘完swb后，如果超过了缓存的swb数量(默认256个wblock)，则重新初始化swb并取消与对应wblock的关联</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ssd_post_write</span><span class="params">(drv_ssd *ssd, ssd_write_buf *swb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先用post_write_q缓存这部分swb先不释放，相当于作为wblock的缓存使用，减少频繁的碎片回收或ssd磁盘读取</span></span><br><span class="line">    <span class="keyword">if</span> (swb-&gt;use_post_write_q &amp;&amp; ssd-&gt;ns-&gt;storage_post_write_queue != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Transfer swb to post-write queue.</span></span><br><span class="line">        <span class="built_in">cf_queue_push</span>(ssd-&gt;post_write_q, &amp;swb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">swb_dereference_and_release</span>(ssd, swb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ssd-&gt;post_write_q) &#123;</span><br><span class="line">        <span class="comment">// Release post-write queue swbs if we&#x27;re over the limit.</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cf_queue_sz</span>(ssd-&gt;post_write_q) &gt;</span><br><span class="line">                ssd-&gt;ns-&gt;storage_post_write_queue) &#123;</span><br><span class="line">            ssd_write_buf* cached_swb;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CF_QUEUE_OK != <span class="built_in">cf_queue_pop</span>(ssd-&gt;post_write_q, &amp;cached_swb,</span><br><span class="line">                    CF_QUEUE_NOWAIT)) &#123;</span><br><span class="line">                <span class="comment">// Should never happen.</span></span><br><span class="line">                <span class="built_in">cf_warning</span>(AS_DRV_SSD, <span class="string">&quot;device %s: post-write queue pop failed&quot;</span>,</span><br><span class="line">                        ssd-&gt;name);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">swb_dereference_and_release</span>(ssd, cached_swb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wblock数据缓存"><a href="#wblock数据缓存" class="headerlink" title="wblock数据缓存"></a>wblock数据缓存</h2><p>aerospike默认的wblock缓存数据较小，以wblock为1M为例，默认只会缓存256个wblock在内存中。其缓存时机为刷盘后不释放。如在</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ssd_post_write</span>(drv_ssd *ssd, ssd_write_buf *swb)</span><br></pre></td></tr></table></figure>
<p>函数中，刷完盘后并不会立马释放swb，而是判断是否大于了缓存数量大小，如果大于后再释放swb。</p>
<p>而对于读record操作，也是先看该缓存是否存在，不存在才重新从ssd中读<strong>record</strong>。</p>
<p>这里有很细节的地方，没有把整个wblock都读进来导致放大写，而是以ssd的最小io大小做地址对齐，读ssd的整数个page，囊括整个record数据，再通过record_size和起始地址等信息，取出需要的部分。</p>
<blockquote>
<p>相当于读操作也是跟ssd底层的按page读原理对应，该读多少读多少，不会放大读。读进来后也不会填充缓存，用完内存直接释放。</p>
</blockquote>
<p>从ssd读record代码如下，做了相应的注释</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">ssd_read_record</span><span class="params">(as_storage_rd *rd, <span class="type">bool</span> pickle_only)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	as_namespace *ns = rd-&gt;ns;</span><br><span class="line">	as_record *r = rd-&gt;r;</span><br><span class="line">	drv_ssd *ssd = rd-&gt;ssd;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint64_t</span> record_offset = <span class="built_in">RBLOCK_ID_TO_OFFSET</span>(r-&gt;rblock_id);</span><br><span class="line">	<span class="type">uint32_t</span> record_size = <span class="built_in">N_RBLOCKS_TO_SIZE</span>(r-&gt;n_rblocks);</span><br><span class="line">	<span class="type">uint64_t</span> record_end_offset = record_offset + record_size;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> wblock_id = <span class="built_in">OFFSET_TO_WBLOCK_ID</span>(ssd, record_offset);</span><br><span class="line">    ...</span><br><span class="line">	<span class="type">uint8_t</span> *read_buf = <span class="literal">NULL</span>;</span><br><span class="line">	as_flat_record *flat = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	ssd_write_buf *swb = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 这里便是看wblock_state中的swb是否存在，即刷盘后没释放，如果存在则增加引用计数hold住，直接拿来用即可</span></span><br><span class="line">	<span class="built_in">swb_check_and_reserve</span>(&amp;ssd-&gt;wblock_state[wblock_id], &amp;swb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有缓存数据，那么直接用</span></span><br><span class="line">	<span class="keyword">if</span> (swb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">// Data is in write buffer, so read it from there.</span></span><br><span class="line">		<span class="built_in">as_incr_uint32</span>(&amp;ns-&gt;n_reads_from_cache);</span><br><span class="line"></span><br><span class="line">		read_buf = <span class="built_in">cf_malloc</span>(record_size);</span><br><span class="line">		flat = (as_flat_record*)read_buf;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> swb_offset = record_offset - <span class="built_in">WBLOCK_ID_TO_OFFSET</span>(ssd, wblock_id);</span><br><span class="line">		<span class="built_in">memcpy</span>(read_buf, swb-&gt;buf + swb_offset, record_size);</span><br><span class="line">		<span class="built_in">swb_release</span>(swb);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">ssd_decrypt_whole</span>(ssd, record_offset, r-&gt;n_rblocks, flat);</span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 无缓存数据，以ssd的page地址对齐，读出对应的所有page，再取出record</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 统计信息，读从ssd中了。而不是从cache</span></span><br><span class="line">		<span class="built_in">as_incr_uint32</span>(&amp;ns-&gt;n_reads_from_device);</span><br><span class="line">        <span class="comment">// 做ssd的page级别的地址对齐，用于direct-io</span></span><br><span class="line">		<span class="type">uint64_t</span> read_offset = <span class="built_in">BYTES_DOWN_TO_IO_MIN</span>(ssd, record_offset);</span><br><span class="line">		<span class="type">uint64_t</span> read_end_offset = <span class="built_in">BYTES_UP_TO_IO_MIN</span>(ssd, record_end_offset);</span><br><span class="line">		<span class="type">size_t</span> read_size = read_end_offset - read_offset;</span><br><span class="line">		<span class="type">uint64_t</span> record_buf_indent = record_offset - read_offset;</span><br><span class="line"></span><br><span class="line">		read_buf = <span class="built_in">cf_valloc</span>(read_size);</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> fd = rd-&gt;read_page_cache ? <span class="built_in">ssd_fd_cache_get</span>(ssd) : <span class="built_in">ssd_fd_get</span>(ssd);</span><br><span class="line"></span><br><span class="line">		<span class="type">uint64_t</span> start_ns = ns-&gt;storage_benchmarks_enabled ? <span class="built_in">cf_getns</span>() : <span class="number">0</span>;</span><br><span class="line">		<span class="type">uint64_t</span> start_us = <span class="built_in">as_health_sample_device_read</span>() ? <span class="built_in">cf_getus</span>() : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 可以看到并没有读整个wblock，而是按需读取page</span></span><br><span class="line">		<span class="keyword">if</span> (! <span class="built_in">pread_all</span>(fd, read_buf, read_size, (<span class="type">off_t</span>)read_offset)) &#123;</span><br><span class="line">            ... <span class="comment">//错误处理，忽略代码</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        ...</span><br><span class="line">		<span class="built_in">as_health_add_device_latency</span>(ns-&gt;ix, r-&gt;file_id, start_us);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (rd-&gt;read_page_cache) &#123;</span><br><span class="line">			<span class="built_in">ssd_fd_cache_put</span>(ssd, fd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">ssd_fd_put</span>(ssd, fd);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		flat = (as_flat_record*)(read_buf + record_buf_indent);</span><br><span class="line">		<span class="built_in">ssd_decrypt_whole</span>(ssd, record_offset, r-&gt;n_rblocks, flat);  </span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 后面都是record数据解析，不用关心</span></span><br><span class="line">	rd-&gt;flat = flat;</span><br><span class="line">	rd-&gt;read_buf = read_buf; <span class="comment">// no need to free read_buf on error now</span></span><br><span class="line"></span><br><span class="line">	as_flat_opt_meta opt_meta = &#123; &#123; <span class="number">0</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Includes round rblock padding, so may not literally exclude the mark.</span></span><br><span class="line">	<span class="comment">// (Is set exactly to mark below, if skipping or decompressing bins.)</span></span><br><span class="line">	rd-&gt;flat_end = (<span class="type">const</span> <span class="type">uint8_t</span>*)flat + record_size - END_MARK_SZ;</span><br><span class="line">	rd-&gt;flat_bins = <span class="built_in">as_flat_unpack_record_meta</span>(flat, rd-&gt;flat_end, &amp;opt_meta);</span><br><span class="line">	rd-&gt;flat_n_bins = (<span class="type">uint16_t</span>)opt_meta.n_bins;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pickle_only) &#123;</span><br><span class="line">		<span class="keyword">if</span> (! <span class="built_in">as_flat_skip_bins</span>(&amp;opt_meta.cm, rd)) &#123;</span><br><span class="line">			<span class="built_in">cf_warning</span>(AS_DRV_SSD, <span class="string">&quot;&#123;%s&#125; read %s: digest %pD bad bin data&quot;</span>,</span><br><span class="line">					ns-&gt;name, ssd-&gt;name, &amp;r-&gt;keyd);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (! <span class="built_in">as_flat_decompress_bins</span>(&amp;opt_meta.cm, rd)) &#123;</span><br><span class="line">		<span class="built_in">cf_warning</span>(AS_DRV_SSD, <span class="string">&quot;&#123;%s&#125; read %s: digest %pD bad compressed data&quot;</span>,</span><br><span class="line">				ns-&gt;name, ssd-&gt;name, &amp;r-&gt;keyd);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (opt_meta.key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		rd-&gt;key_size = opt_meta.key_size;</span><br><span class="line">		rd-&gt;key = opt_meta.key;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// else - if updating record without key, leave rd (msg) key to be stored.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="日志打印摘录与注释"><a href="#日志打印摘录与注释" class="headerlink" title="日志打印摘录与注释"></a>日志打印摘录与注释</h2><p>主要摘录了启动过程到稳定运行过程的日志，方便理解全过程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全盘扫描阶段.device-pcts表示扫描了百分之多少的磁盘了。</span></span><br><span class="line">Mar 31 2025 05:39:03 GMT: INFO (drv_ssd): (drv_ssd.c:3812) &#123;test&#125; loaded: objects 1196746282 device-pcts (30)</span><br><span class="line">Mar 31 2025 05:39:08 GMT: INFO (drv_ssd): (drv_ssd.c:3812) &#123;test&#125; loaded: objects 1196747454 device-pcts (30)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全盘扫描总结，独特数据为UNIQUE，REPLACED表示重复数据并选取了最新的数据的数量，OLDER表示重复数据选取了老数据的数据量</span></span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (drv_ssd): (drv_ssd.c:2840) device /dev/nvme0n1: read complete: UNIQUE 1196749999 (REPLACED 342376538) (OLDE</span><br><span class="line">R 838422240) (EXPIRED 0) (EVICTED 0) records</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始磁盘垃圾回收和碎片整理</span></span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (drv_ssd): (drv_ssd.c:1024) &#123;test&#125; loading free &amp; defrag queues</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印每一个碎片百分比，需要碎片整理的w_block数量。比如下面说(0~1)%实际数据的块有856个。</span></span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (drv_ssd): (drv_ssd.c:958) /dev/nvme0n1 init defrag profile: 856,1008,1030,1290,3630,2226,2053,1882,2037,310</span><br><span class="line">0,3111,3383,3809,3671,4282,4426,5254,5339,5828,6068,6420,7045,7405,7633,7933,7734,8015,7956,8149,7982,8152,7543,7523,7557,7351,7075,6918,64</span><br><span class="line">57,6267,6216,6306,6129,6199,6555,6815,7419,8191,8917,9542,10305</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印当前统计情况。即需回收块数量为free-q=11517，需碎片整理的block数量为defrag-q=287992</span></span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (drv_ssd): (drv_ssd.c:1043) /dev/nvme0n1 init wblocks: pristine-id 632993 pristine 1464159 free-q 11517, def</span><br><span class="line">rag-q 287992</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下开始准备对外服务的各个线程了</span></span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (drv_ssd): (drv_ssd.c:2305) &#123;test&#125; starting device maintenance threads</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (drv_ssd): (drv_ssd.c:1654) &#123;test&#125; starting write threads</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (drv_ssd): (drv_ssd.c:878) &#123;test&#125; starting defrag threads</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (as): (as.c:384) initializing services...</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (service): (service.c:166) starting 320 service threads</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (fabric): (fabric.c:791) updated fabric published address list to &#123;10.52.0.230:3001&#125;</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (partition): (partition_balance.c:204) &#123;test&#125; 4096 partitions: found 0 absent, 4096 stored</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (smd): (smd.c:2346) no file &#x27;/opt/aerospike/smd/UDF.smd&#x27; - starting empty</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (batch): (batch.c:821) starting 64 batch-index-threads</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (health): (health.c:327) starting health monitor thread</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (fabric): (fabric.c:416) starting 8 fabric send threads</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (fabric): (fabric.c:430) starting 16 fabric rw channel recv threads</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (fabric): (fabric.c:430) starting 4 fabric ctrl channel recv threads</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (fabric): (fabric.c:430) starting 4 fabric bulk channel recv threads</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (fabric): (fabric.c:430) starting 4 fabric meta channel recv threads</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (fabric): (fabric.c:442) starting fabric accept thread</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (hb): (hb.c:7165) initializing multicast heartbeat socket: 239.1.99.222:9918</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (fabric): (socket.c:825) Started fabric endpoint 0.0.0.0:3001</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (socket): (socket.c:1582) Joining multicast group: 239.1.99.222</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (hb): (hb.c:7199) mtu of the network is 1500</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (hb): (socket.c:1618) Started multicast heartbeat endpoint 0.0.0.0:9918</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (nsup): (nsup.c:197) starting namespace supervisor threads</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (service): (service.c:943) starting reaper thread</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (service): (socket.c:825) Started client endpoint 0.0.0.0:3000</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (service): (service.c:198) starting accept thread</span><br><span class="line">Mar 31 2025 05:39:12 GMT: INFO (as): (as.c:423) service ready: soon there will be cake!</span><br><span class="line">Mar 31 2025 05:39:13 GMT: INFO (nsup): (nsup.c:1009) &#123;test&#125; collecting ttl &amp; object size info ...</span><br><span class="line">Mar 31 2025 05:39:14 GMT: INFO (clustering): (clustering.c:6357) principal node - forming new cluster with succession list: bb9603b99ef9408</span><br><span class="line">Mar 31 2025 05:39:14 GMT: INFO (clustering): (clustering.c:5797) applied new cluster key 248829370ef3</span><br><span class="line">Mar 31 2025 05:39:14 GMT: INFO (clustering): (clustering.c:5799) applied new succession list bb9603b99ef9408</span><br><span class="line">Mar 31 2025 05:39:14 GMT: INFO (clustering): (clustering.c:5801) applied cluster size 1</span><br><span class="line">Mar 31 2025 05:39:14 GMT: INFO (exchange): (exchange.c:2345) data exchange started with cluster key 248829370ef3</span><br><span class="line">Mar 31 2025 05:39:14 GMT: INFO (exchange): (exchange.c:2728) exchange-compatibility-id: self 14 cluster-min 0 -&gt; 14 cluster-max 0 -&gt; 14</span><br><span class="line">Mar 31 2025 05:39:14 GMT: INFO (exchange): (exchange.c:3296) received commit command from principal node bb9603b99ef9408</span><br><span class="line">Mar 31 2025 05:39:14 GMT: INFO (exchange): (exchange.c:3259) data exchange completed with cluster key 248829370ef3</span><br><span class="line">Mar 31 2025 05:39:14 GMT: INFO (partition): (partition_balance.c:1046) &#123;test&#125; replication factor is 1</span><br><span class="line">Mar 31 2025 05:39:14 GMT: INFO (partition): (partition_balance.c:1019) &#123;test&#125; rebalanced: expected-migrations (0,0,0) fresh-partitions 0</span><br><span class="line">Mar 31 2025 05:39:22 GMT: INFO (info): (ticker.c:167) NODE-ID bb9603b99ef9408 CLUSTER-SIZE 1 CLUSTER-NAME cakery</span><br><span class="line">Mar 31 2025 05:39:22 GMT: INFO (info): (ticker.c:239)    cluster-clock: skew-ms 0</span><br><span class="line">Mar 31 2025 05:39:22 GMT: INFO (info): (ticker.c:260)    system: total-cpu-pct 164 user-cpu-pct 125 kernel-cpu-pct 39 free-mem-kbytes 52202</span><br><span class="line">552 free-mem-pct 39 thp-mem-kbytes 30720</span><br><span class="line">Mar 31 2025 05:39:22 GMT: INFO (info): (ticker.c:282)    process: cpu-pct 157 threads (8,60,401,401) heap-kbytes (75726946,75743760,7577446</span><br><span class="line">4) heap-efficiency-pct 100.0</span><br><span class="line">Mar 31 2025 05:39:22 GMT: INFO (info): (ticker.c:292)    in-progress: info-q 0 rw-hash 0 proxy-hash 0 tree-gc-q 0 long-queries 0</span><br><span class="line">Mar 31 2025 05:39:22 GMT: INFO (info): (ticker.c:316)    fds: proto (0,0,0) heartbeat (0,0,0) fabric (0,0,0)</span><br><span class="line">Mar 31 2025 05:39:22 GMT: INFO (info): (ticker.c:325)    heartbeat-received: self 67 foreign 0</span><br><span class="line">Mar 31 2025 05:39:22 GMT: INFO (info): (ticker.c:351)    fabric-bytes-per-second: bulk (0,0) ctrl (0,0) meta (0,0) rw (0,0)</span><br><span class="line">Mar 31 2025 05:39:22 GMT: INFO (info): (ticker.c:410) &#123;test&#125; objects: all 1196749999 master 1196749999 prole 0 non-replica 0</span><br><span class="line">Mar 31 2025 05:39:22 GMT: INFO (info): (ticker.c:474) &#123;test&#125; migrations: complete</span><br><span class="line">Mar 31 2025 05:39:22 GMT: INFO (info): (ticker.c:504) &#123;test&#125; index-usage: used-bytes 76591999936</span><br><span class="line">Mar 31 2025 05:39:22 GMT: INFO (info): (ticker.c:566) &#123;test&#125; data-usage: used-bytes 330368494752 avail-pct 70 cache-read-pct 0.00</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">free-wblocks:空闲(可用)块数、write(41,2) swb-buffer刷盘总数41，刷盘速率2.0。defrag-q：当前defrag队列堆积数。defrag-read(287992,14399)碎片整理队列堆积总数(全历史)与队列堆积速率(当前)</span></span><br><span class="line">Mar 31 2025 05:39:32 GMT: INFO (drv_ssd): (drv_ssd.c:2035) &#123;test&#125; /dev/nvme0n1: used-bytes 330368494752 free-wblocks 1478345 write-q 0 writ</span><br><span class="line">e (41,2.0) defrag-q 285258 defrag-read (287992,14399.6) defrag-write (41,2.0)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025-04-28-hash%E5%BC%95%E6%93%8E%E8%AE%BE%E8%AE%A1%E9%9A%BE%E7%82%B9(1)-%E9%9D%9E%E5%8E%9F%E5%AD%90%E6%80%A7%E8%AF%BB%E5%86%99/" rel="prev" title="hash引擎设计难点(1)-非原子性读写">
                  <i class="fa fa-angle-left"></i> hash引擎设计难点(1)-非原子性读写
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Corgis</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
