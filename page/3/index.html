<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/project/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/project/images/corgis.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/project/images/corgis.jpg">
  <link rel="mask-icon" href="/project/images/logo.svg" color="#222">

<link rel="stylesheet" href="/project/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scut-corgis.github.io","root":"/project/","images":"/project/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/project/js/config.js"></script>

    <meta name="description" content="用于成长过程中，记录值得对外分享的技术，如开源代码理解、国外课程项目，个人对一些领域的心得等">
<meta property="og:type" content="website">
<meta property="og:title" content="corgis的笔记">
<meta property="og:url" content="https://scut-corgis.github.io/project/page/3/index.html">
<meta property="og:site_name" content="corgis的笔记">
<meta property="og:description" content="用于成长过程中，记录值得对外分享的技术，如开源代码理解、国外课程项目，个人对一些领域的心得等">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Corgis">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://scut-corgis.github.io/project/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>corgis的笔记</title>
  








  <noscript>
    <link rel="stylesheet" href="/project/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/project/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">corgis的笔记</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/project/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/project/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/project/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/project/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Corgis"
      src="/project/images/corgis.jpg">
  <p class="site-author-name" itemprop="name">Corgis</p>
  <div class="site-description" itemprop="description">用于成长过程中，记录值得对外分享的技术，如开源代码理解、国外课程项目，个人对一些领域的心得等</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/project/archives/">
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/project/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://scut-corgis.github.io/project/2024-08-15-twemproxy%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/corgis.jpg">
      <meta itemprop="name" content="Corgis">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corgis的笔记">
      <meta itemprop="description" content="用于成长过程中，记录值得对外分享的技术，如开源代码理解、国外课程项目，个人对一些领域的心得等">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | corgis的笔记">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/project/2024-08-15-twemproxy%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">twemproxy核心流程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-15 22:30:05" itemprop="dateCreated datePublished" datetime="2024-08-15T22:30:05+08:00">2024-08-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/project/categories/twemproxy/" itemprop="url" rel="index"><span itemprop="name">twemproxy</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a target="_blank" rel="noopener" href="https://github.com/twitter/twemproxy">github-readme-开源链接</a></p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>redis集群模式难以真正的大规模水平扩展，gossip模式不适合企业生产环境。但使用哨兵模式，单机容量不足以支持大数据量，因此twemproxy最主要的目的是解决了<strong>redis水平扩展问题</strong>。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>通过一致性哈希等负载均衡方式，可以给twemproxy配置多个redis(主)节点，twemproxy会自动对键操作做路由，相当于做了一层路由层，实现了键分片的效果，本质上与redis的cluster模式的slots方式相同。</p>
<p>twemproxy对使用redis的用户看来，跟redis没有区别，twemproxy可以将其理解为转发层。至于如何访问到twemproxy，可以使用dns等方式的实现。</p>
<p>一般搭配redis哨兵实现，哨兵负责主从切换，并通过故障切换后自动执行的脚本来修改twemproxy的配置文件，并对其重启加载最新主节点信息。</p>
<p><img src="/project/2024-08-15-twemproxy%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/deploy_structure.png"></p>
<h2 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_25241721/article/details/116769633">部署Twemproxy集群-CSDN</a></p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/foxmailed/p/3623817.html">twemproxy源码解析 - 博客园</a></p>
<h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>几乎所有的C&#x2F;C++的网络编程代码都是围绕epoll的reactor模式的两个半事件展开</p>
<ul>
<li>收到消息</li>
<li>消息处理完毕</li>
<li>消息发送完毕</li>
</ul>
<p>因此我们只需要抓住这五个事件处理函数，便可以掌握整个组件的核心逻辑。但需要注意的是，twemproxy充当redis-cli与redis之间的桥梁，其会多一些过程，即除了上述服务端的必处理过程。还有作为redis客户端的过程</p>
<ul>
<li>往redis发送消息完毕的处理函数</li>
<li>收到redis回复的消息处理函数</li>
</ul>
<p>当然包括两者的连接管理，即</p>
<ul>
<li>连接建立回调</li>
<li>连接断开回调</li>
</ul>
<p>所有的代码和优化均围绕以上过程展开。因此为了清晰，不在主循环中阐述配置解析、日志处理、数据结构优化等逻辑。先理清楚主循环。</p>
<h3 id="项目网络编程架构"><a href="#项目网络编程架构" class="headerlink" title="项目网络编程架构"></a>项目网络编程架构</h3><p>整个事件处理过程在nc_message.c的注释中给出了比较清晰的图。</p>
<p>client前缀的变量均为客户侧与proxy的连接，server+为proxy与redis的连接，proxy表示监听套接字对应的conn。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*             Client+             Proxy           Server+</span></span><br><span class="line"><span class="comment"> *                              (nutcracker)</span></span><br><span class="line"><span class="comment"> *                                   .</span></span><br><span class="line"><span class="comment"> *       msg_recv &#123;read event&#125;       .       msg_recv &#123;read event&#125;</span></span><br><span class="line"><span class="comment"> *         +                         .                         +</span></span><br><span class="line"><span class="comment"> *         |                         .                         |</span></span><br><span class="line"><span class="comment"> *         \                         .                         /</span></span><br><span class="line"><span class="comment"> *         req_recv_next             .             rsp_recv_next</span></span><br><span class="line"><span class="comment"> *           +                       .                       +</span></span><br><span class="line"><span class="comment"> *           |                       .                       |       Rsp</span></span><br><span class="line"><span class="comment"> *           req_recv_done           .           rsp_recv_done      &lt;===</span></span><br><span class="line"><span class="comment"> *             +                     .                     +</span></span><br><span class="line"><span class="comment"> *             |                     .                     |</span></span><br><span class="line"><span class="comment"> *    Req      \                     .                     /</span></span><br><span class="line"><span class="comment"> *    ===&gt;     req_filter*           .           *rsp_filter</span></span><br><span class="line"><span class="comment"> *               +                   .                   +</span></span><br><span class="line"><span class="comment"> *               |                   .                   |</span></span><br><span class="line"><span class="comment"> *               \                   .                   /</span></span><br><span class="line"><span class="comment"> *               req_forward-//  (a) . (c)  \\-rsp_forward</span></span><br><span class="line"><span class="comment"> *                                   .</span></span><br><span class="line"><span class="comment"> *                                   .</span></span><br><span class="line"><span class="comment"> *       msg_send &#123;write event&#125;      .      msg_send &#123;write event&#125;</span></span><br><span class="line"><span class="comment"> *         +                         .                         +</span></span><br><span class="line"><span class="comment"> *         |                         .                         |</span></span><br><span class="line"><span class="comment"> *    Rsp&#x27; \                         .                         /     Req&#x27;</span></span><br><span class="line"><span class="comment"> *   &lt;===  rsp_send_next             .             req_send_next     ===&gt;</span></span><br><span class="line"><span class="comment"> *           +                       .                       +</span></span><br><span class="line"><span class="comment"> *           |                       .                       |</span></span><br><span class="line"><span class="comment"> *           \                       .                       /</span></span><br><span class="line"><span class="comment"> *           rsp_send_done-//    (d) . (b)    //-req_send_done</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (a) -&gt; (b) -&gt; (c) -&gt; (d) is the normal flow of transaction consisting</span></span><br><span class="line"><span class="comment"> * of a single request response, where (a) and (b) handle request from</span></span><br><span class="line"><span class="comment"> * client, while (c) and (d) handle the corresponding response from the</span></span><br><span class="line"><span class="comment"> * server.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><img src="/project/2024-08-15-twemproxy%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B/accept_flow.svg" alt="twemproxy请求流程"></p>
<p>对于消息的处理过程如下，每个conn均有一个消息入队列in_q，与出队列out_q，每一个队列元素为msg，而msg由更细粒度的字符串数组mbuf构成。</p>
<p>client收到消息便往in_q存，触发读事件回调，读事件回调会将消息转发到已选择的server端in_q，并且往自身out_q里面存。</p>
<p>server读回调处理自身in_q，发给redis，每发完一个完整req便放到自身out_q里面，当redis回复完毕，从out_q里面取出队头，从里面获取client的连接对应信息，触发client对应连接的写事件。</p>
<p>client写事件处理回调，会将redis的respond回给用户侧。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*                    引用nc_connection.c的注释</span></span><br><span class="line"><span class="comment"> *    Clients                             Servers</span></span><br><span class="line"><span class="comment"> *                                    .</span></span><br><span class="line"><span class="comment"> *    in_q: &lt;empty&gt;                   .</span></span><br><span class="line"><span class="comment"> *    out_q: req11 -&gt; req12           .   in_q:  req22</span></span><br><span class="line"><span class="comment"> *    (client1)                       .   out_q: req11 -&gt; req21 -&gt; req12</span></span><br><span class="line"><span class="comment"> *                                    .   (server1)</span></span><br><span class="line"><span class="comment"> *    in_q: &lt;empty&gt;                   .</span></span><br><span class="line"><span class="comment"> *    out_q: req21 -&gt; req22 -&gt; req23  .</span></span><br><span class="line"><span class="comment"> *    (client2)                       .</span></span><br><span class="line"><span class="comment"> *                                    .   in_q:  req23</span></span><br><span class="line"><span class="comment"> *                                    .   out_q: &lt;empty&gt;</span></span><br><span class="line"><span class="comment">* /                                   .   (server2)</span></span><br></pre></td></tr></table></figure>

<h4 id="回调注册"><a href="#回调注册" class="headerlink" title="回调注册"></a>回调注册</h4><p>程序在启动时于<code>nc_core.c</code>中注册了所有连接的回调入口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> context* <span class="title function_">core_ctx_create</span><span class="params">(<span class="keyword">struct</span> instance *nci)</span></span><br><span class="line">    <span class="comment">/* initialize event handling for client, proxy and server */</span></span><br><span class="line">    ctx-&gt;evb = event_base_create(EVENT_SIZE, &amp;core_core);</span><br><span class="line"></span><br><span class="line"><span class="type">rstatus_t</span></span><br><span class="line"><span class="title function_">core_core</span><span class="params">(<span class="type">void</span> *arg, <span class="type">uint32_t</span> events)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rstatus_t</span> status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn</span> *<span class="title">conn</span> =</span> arg;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">ctx</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    ctx = conn_to_ctx(conn);</span><br><span class="line"></span><br><span class="line">    conn-&gt;events = events;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* error takes precedence over read | write */</span></span><br><span class="line">    <span class="keyword">if</span> (events &amp; EVENT_ERR) &#123;</span><br><span class="line">        core_error(ctx, conn);</span><br><span class="line">        <span class="keyword">return</span> NC_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* read takes precedence over write */</span></span><br><span class="line">    <span class="keyword">if</span> (events &amp; EVENT_READ) &#123;</span><br><span class="line">        <span class="comment">// 可以看到所有的连接都会走core_recv</span></span><br><span class="line">        status = core_recv(ctx, conn);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; EVENT_WRITE) &#123;</span><br><span class="line">        <span class="comment">// 写同理</span></span><br><span class="line">        status = core_send(ctx, conn);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NC_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以core_recv为例，可以看到所有的实际处理过程转发给的conn自身注册的回调</span></span><br><span class="line"><span class="type">static</span> <span class="type">rstatus_t</span></span><br><span class="line"><span class="title function_">core_recv</span><span class="params">(<span class="keyword">struct</span> context *ctx, <span class="keyword">struct</span> conn *conn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rstatus_t</span> status;</span><br><span class="line">    status = conn-&gt;recv(ctx, conn);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此所有的实际回调函数均与conn绑定，在conn创建时绑定其函数指针</p>
<h4 id="conn创建"><a href="#conn创建" class="headerlink" title="conn创建"></a>conn创建</h4><p>可以看到下面创建conn函数针对不同的连接类型，注册了相应的回调，因此这是我们理清主循环的重要函数入口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nc_connection.c</span></span><br><span class="line"><span class="keyword">struct</span> conn *</span><br><span class="line"><span class="title function_">conn_get</span><span class="params">(<span class="type">void</span> *owner, <span class="type">bool</span> client, <span class="type">bool</span> redis)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn</span> *<span class="title">conn</span>;</span></span><br><span class="line"></span><br><span class="line">    conn = _conn_get();</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* connection either handles redis or memcache messages */</span></span><br><span class="line">    conn-&gt;redis = redis ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    conn-&gt;client = client ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;client) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * client receives a request, possibly parsing it, and sends a</span></span><br><span class="line"><span class="comment">         * response downstream.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        conn-&gt;recv = msg_recv;</span><br><span class="line">        conn-&gt;recv_next = req_recv_next;</span><br><span class="line">        conn-&gt;recv_done = req_recv_done;</span><br><span class="line"></span><br><span class="line">        conn-&gt;send = msg_send;</span><br><span class="line">        conn-&gt;send_next = rsp_send_next;</span><br><span class="line">        conn-&gt;send_done = rsp_send_done;</span><br><span class="line"></span><br><span class="line">        conn-&gt;close = client_close;</span><br><span class="line">        conn-&gt;active = client_active;</span><br><span class="line"></span><br><span class="line">        conn-&gt;ref = client_ref;</span><br><span class="line">        conn-&gt;unref = client_unref;</span><br><span class="line"></span><br><span class="line">        conn-&gt;enqueue_inq = <span class="literal">NULL</span>;</span><br><span class="line">        conn-&gt;dequeue_inq = <span class="literal">NULL</span>;</span><br><span class="line">        conn-&gt;enqueue_outq = req_client_enqueue_omsgq;</span><br><span class="line">        conn-&gt;dequeue_outq = req_client_dequeue_omsgq;</span><br><span class="line">        conn-&gt;post_connect = <span class="literal">NULL</span>;</span><br><span class="line">        conn-&gt;swallow_msg = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        ncurr_cconn++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * server receives a response, possibly parsing it, and sends a</span></span><br><span class="line"><span class="comment">         * request upstream.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        conn-&gt;recv = msg_recv;</span><br><span class="line">        conn-&gt;recv_next = rsp_recv_next;</span><br><span class="line">        conn-&gt;recv_done = rsp_recv_done;</span><br><span class="line"></span><br><span class="line">        conn-&gt;send = msg_send;</span><br><span class="line">        conn-&gt;send_next = req_send_next;</span><br><span class="line">        conn-&gt;send_done = req_send_done;</span><br><span class="line"></span><br><span class="line">        conn-&gt;close = server_close;</span><br><span class="line">        conn-&gt;active = server_active;</span><br><span class="line"></span><br><span class="line">        conn-&gt;ref = server_ref;</span><br><span class="line">        conn-&gt;unref = server_unref;</span><br><span class="line"></span><br><span class="line">        conn-&gt;enqueue_inq = req_server_enqueue_imsgq;</span><br><span class="line">        conn-&gt;dequeue_inq = req_server_dequeue_imsgq;</span><br><span class="line">        conn-&gt;enqueue_outq = req_server_enqueue_omsgq;</span><br><span class="line">        conn-&gt;dequeue_outq = req_server_dequeue_omsgq;</span><br><span class="line">        <span class="keyword">if</span> (redis) &#123;</span><br><span class="line">          conn-&gt;post_connect = redis_post_connect;</span><br><span class="line">          conn-&gt;swallow_msg = redis_swallow_msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          conn-&gt;post_connect = memcache_post_connect;</span><br><span class="line">          conn-&gt;swallow_msg = memcache_swallow_msg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conn-&gt;ref(conn, owner);</span><br><span class="line">    log_debug(LOG_VVERB, <span class="string">&quot;get conn %p client %d&quot;</span>, conn, conn-&gt;client);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>twemproxy可以处理多个redis的集群，每个集群称为一个<code>server_pool</code>，每个server_pood对应多个redis实例。twemproxy没有把所有的pool都用一个监听套接字处理，而是各个pool一个监听套接字，但所有的监听套接字都用一个epoll观察，因此单线程监听连接事件。</p>
<p>如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> context *</span><br><span class="line"><span class="title function_">core_ctx_create</span><span class="params">(<span class="keyword">struct</span> instance *nci)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">/* initialize proxy per server pool */</span></span><br><span class="line">    status = proxy_init(ctx);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">rstatus_t</span></span><br><span class="line"><span class="title function_">proxy_init</span><span class="params">(<span class="keyword">struct</span> context *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rstatus_t</span> status;</span><br><span class="line">    status = array_each(&amp;ctx-&gt;pool, proxy_each_init, <span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">rstatus_t</span></span><br><span class="line"><span class="title function_">proxy_each_init</span><span class="params">(<span class="type">void</span> *elem, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rstatus_t</span> status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">server_pool</span> *<span class="title">pool</span> =</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="comment">// 获取proxy对应的conn，核心回调绑定入口</span></span><br><span class="line">    p = conn_get_proxy(pool);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NC_ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始监听，一些网络编程惯例</span></span><br><span class="line">    status = proxy_listen(pool-&gt;ctx, p);</span><br><span class="line">    <span class="keyword">if</span> (status != NC_OK) &#123;</span><br><span class="line">        p-&gt;close(pool-&gt;ctx, p);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_debug(LOG_NOTICE, <span class="string">&quot;p %d listening on &#x27;%.*s&#x27; in %s pool %&quot;</span>PRIu32<span class="string">&quot; &#x27;%.*s&#x27;&quot;</span></span><br><span class="line">              <span class="string">&quot; with %&quot;</span>PRIu32<span class="string">&quot; servers&quot;</span>, p-&gt;sd, pool-&gt;addrstr.len,</span><br><span class="line">              pool-&gt;addrstr.data, pool-&gt;redis ? <span class="string">&quot;redis&quot;</span> : <span class="string">&quot;memcache&quot;</span>,</span><br><span class="line">              pool-&gt;idx, pool-&gt;name.len, pool-&gt;name.data,</span><br><span class="line">              array_n(&amp;pool-&gt;server));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NC_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> conn *</span><br><span class="line"><span class="title function_">conn_get_proxy</span><span class="params">(<span class="keyword">struct</span> server_pool *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn</span> *<span class="title">conn</span>;</span></span><br><span class="line"></span><br><span class="line">    conn = _conn_get();</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conn-&gt;redis = pool-&gt;redis;</span><br><span class="line"></span><br><span class="line">    conn-&gt;proxy = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 连接建立回调</span></span><br><span class="line">    conn-&gt;recv = proxy_recv;</span><br><span class="line">    conn-&gt;recv_next = <span class="literal">NULL</span>;</span><br><span class="line">    conn-&gt;recv_done = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    conn-&gt;send = <span class="literal">NULL</span>;</span><br><span class="line">    conn-&gt;send_next = <span class="literal">NULL</span>;</span><br><span class="line">    conn-&gt;send_done = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 连接关闭回调</span></span><br><span class="line">    conn-&gt;close = proxy_close;</span><br><span class="line">    conn-&gt;active = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    conn-&gt;ref = proxy_ref;</span><br><span class="line">    conn-&gt;unref = proxy_unref;</span><br><span class="line"></span><br><span class="line">    conn-&gt;enqueue_inq = <span class="literal">NULL</span>;</span><br><span class="line">    conn-&gt;dequeue_inq = <span class="literal">NULL</span>;</span><br><span class="line">    conn-&gt;enqueue_outq = <span class="literal">NULL</span>;</span><br><span class="line">    conn-&gt;dequeue_outq = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 这里绑定了proxy_conn的owner为对应的server_pool</span></span><br><span class="line">    conn-&gt;ref(conn, pool);</span><br><span class="line"></span><br><span class="line">    log_debug(LOG_VVERB, <span class="string">&quot;get conn %p proxy %d&quot;</span>, conn, conn-&gt;proxy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="连接回调"><a href="#连接回调" class="headerlink" title="连接回调"></a>连接回调</h3><p>下面以时间线的方式展开说明各个回调函数。从连接发起，用户侧命令发送到twemproxy回复用户侧结束。</p>
<h4 id="用户侧连接twemproxy"><a href="#用户侧连接twemproxy" class="headerlink" title="用户侧连接twemproxy"></a>用户侧连接twemproxy</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入口函数，可以看到会一直读到EAGAIN，一次处理完所有发起的连接</span></span><br><span class="line"><span class="type">rstatus_t</span></span><br><span class="line"><span class="title function_">proxy_recv</span><span class="params">(<span class="keyword">struct</span> context *ctx, <span class="keyword">struct</span> conn *conn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rstatus_t</span> status;</span><br><span class="line">    conn-&gt;recv_ready = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        status = proxy_accept(ctx, conn);</span><br><span class="line">        <span class="keyword">if</span> (status != NC_OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (conn-&gt;recv_ready);</span><br><span class="line">    <span class="keyword">return</span> NC_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码相当清晰，accept一个连接，创建client的conn，加入</span></span><br><span class="line"><span class="type">static</span> <span class="type">rstatus_t</span></span><br><span class="line"><span class="title function_">proxy_accept</span><span class="params">(<span class="keyword">struct</span> context *ctx, <span class="keyword">struct</span> conn *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rstatus_t</span> status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn</span> *<span class="title">c</span>;</span></span><br><span class="line">    <span class="type">int</span> sd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">server_pool</span> *<span class="title">pool</span> =</span> p-&gt;owner;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        sd = accept(p-&gt;sd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (sd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                log_debug(LOG_VERB, <span class="string">&quot;accept on p %d not ready - eintr&quot;</span>, p-&gt;sd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从这里可以看到会读到EAGAIN</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK || errno == ECONNABORTED) &#123;</span><br><span class="line">                log_debug(LOG_VERB, <span class="string">&quot;accept on p %d not ready - eagain&quot;</span>, p-&gt;sd);</span><br><span class="line">                p-&gt;recv_ready = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> NC_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            log_error(<span class="string">&quot;accept on p %d failed: %s&quot;</span>, p-&gt;sd, strerror(errno));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> NC_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// client会存在连接最大数量，这是根据文件描述符的可用数在程序初始化时计算的</span></span><br><span class="line">    <span class="keyword">if</span> (conn_ncurr_cconn() &gt;= ctx-&gt;max_ncconn) &#123;</span><br><span class="line">        log_debug(LOG_CRIT, <span class="string">&quot;client connections %&quot;</span>PRIu32<span class="string">&quot; exceed limit %&quot;</span>PRIu32,</span><br><span class="line">                  conn_ncurr_cconn(), ctx-&gt;max_ncconn);</span><br><span class="line">        status = close(sd);</span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_error(<span class="string">&quot;close c %d failed, ignored: %s&quot;</span>, sd, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NC_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处获取client的conn，并绑定相应回调</span></span><br><span class="line">    c = conn_get(p-&gt;owner, <span class="literal">true</span>, p-&gt;redis);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        log_error(<span class="string">&quot;get conn for c %d from p %d failed: %s&quot;</span>, sd, p-&gt;sd,</span><br><span class="line">                  strerror(errno));</span><br><span class="line">        status = close(sd);</span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_error(<span class="string">&quot;close c %d failed, ignored: %s&quot;</span>, sd, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NC_ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    c-&gt;sd = sd;</span><br><span class="line"></span><br><span class="line">    stats_pool_incr(ctx, c-&gt;owner, client_connections);</span><br><span class="line"></span><br><span class="line">    status = nc_set_nonblocking(c-&gt;sd);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_error(<span class="string">&quot;set nonblock on c %d from p %d failed: %s&quot;</span>, c-&gt;sd, p-&gt;sd,</span><br><span class="line">                  strerror(errno));</span><br><span class="line">        c-&gt;close(ctx, c);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;tcpkeepalive) &#123;</span><br><span class="line">        status = nc_set_tcpkeepalive(c-&gt;sd);</span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_warn(<span class="string">&quot;set tcpkeepalive on c %d from p %d failed, ignored: %s&quot;</span>,</span><br><span class="line">                     c-&gt;sd, p-&gt;sd, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;family == AF_INET || p-&gt;family == AF_INET6) &#123;</span><br><span class="line">        status = nc_set_tcpnodelay(c-&gt;sd);</span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            log_warn(<span class="string">&quot;set tcpnodelay on c %d from p %d failed, ignored: %s&quot;</span>,</span><br><span class="line">                     c-&gt;sd, p-&gt;sd, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里加入了epoll监听循环中，能看出全部的conn都是用一个epoll，因此twemproxy纯单线程处理所有连接</span></span><br><span class="line">    status = event_add_conn(ctx-&gt;evb, c);</span><br><span class="line">    <span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        log_error(<span class="string">&quot;event add conn from p %d failed: %s&quot;</span>, p-&gt;sd,</span><br><span class="line">                  strerror(errno));</span><br><span class="line">        c-&gt;close(ctx, c);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_debug(LOG_NOTICE, <span class="string">&quot;accepted c %d on p %d from &#x27;%s&#x27;&quot;</span>, c-&gt;sd, p-&gt;sd,</span><br><span class="line">              nc_unresolve_peer_desc(c-&gt;sd));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NC_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="用户侧发起命令给twemproxy"><a href="#用户侧发起命令给twemproxy" class="headerlink" title="用户侧发起命令给twemproxy"></a>用户侧发起命令给twemproxy</h4><p>首先是入口函数，其本身并未做什么，直接将请求传递给<code>recv_next</code>与<code>msg_recv_chain</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rstatus_t</span></span><br><span class="line"><span class="title function_">msg_recv</span><span class="params">(<span class="keyword">struct</span> context *ctx, <span class="keyword">struct</span> conn *conn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rstatus_t</span> status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    conn-&gt;recv_ready = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        msg = conn-&gt;recv_next(ctx, conn, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> NC_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        status = msg_recv_chain(ctx, conn, msg);</span><br><span class="line">        <span class="keyword">if</span> (status != NC_OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (conn-&gt;recv_ready);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NC_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg *</span><br><span class="line"><span class="title function_">req_recv_next</span><span class="params">(<span class="keyword">struct</span> context *ctx, <span class="keyword">struct</span> conn *conn, <span class="type">bool</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg</span>;</span></span><br><span class="line">    <span class="comment">// eof标志在当前tcp缓冲区读完时置1, 直接退出外层for循环，结束这次msg_recv过程</span></span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;eof) &#123;</span><br><span class="line">        ... </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出上一次处理得到的msg。rmsg指向当前读队列的待处理的msg</span></span><br><span class="line">    msg = conn-&gt;rmsg;</span><br><span class="line">    <span class="comment">// 不为空则直接去后续处理该msg</span></span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 否则申请一个新的空的msg，用于read当前tcp数据与处理</span></span><br><span class="line">    msg = req_get(conn);</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        conn-&gt;rmsg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">rstatus_t</span></span><br><span class="line"><span class="title function_">msg_recv_chain</span><span class="params">(<span class="keyword">struct</span> context *ctx, <span class="keyword">struct</span> conn *conn, <span class="keyword">struct</span> msg *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rstatus_t</span> status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">nmsg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">mbuf</span>;</span></span><br><span class="line">    <span class="type">size_t</span> msize;</span><br><span class="line">    <span class="type">ssize_t</span> n;</span><br><span class="line">    <span class="comment">// 获取该msg的最后一个mbuf</span></span><br><span class="line">    mbuf = STAILQ_LAST(&amp;msg-&gt;mhdr, mbuf, next);</span><br><span class="line">    <span class="comment">// 如果mbuf为空或者满了，申请一个新的，尾插入链表</span></span><br><span class="line">    <span class="keyword">if</span> (mbuf == <span class="literal">NULL</span> || mbuf_full(mbuf)) &#123;</span><br><span class="line">        mbuf = mbuf_get();</span><br><span class="line">        <span class="keyword">if</span> (mbuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> NC_ENOMEM;</span><br><span class="line">        &#125;</span><br><span class="line">        mbuf_insert(&amp;msg-&gt;mhdr, mbuf);</span><br><span class="line">        msg-&gt;pos = mbuf-&gt;pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取mbuf剩余空间大小</span></span><br><span class="line">    msize = mbuf_size(mbuf);</span><br><span class="line">    <span class="comment">// 从mbuf-&gt;last位置读入最多msize字节的数据，这里是tcp读取真实入口</span></span><br><span class="line">    n = conn_recv(conn, mbuf-&gt;last, msize);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == NC_EAGAIN) &#123;</span><br><span class="line">            <span class="keyword">return</span> NC_OK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NC_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    mbuf-&gt;last += n;</span><br><span class="line">    msg-&gt;mlen += (<span class="type">uint32_t</span>)n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        status = msg_parse(ctx, conn, msg);</span><br><span class="line">        <span class="keyword">if</span> (status != NC_OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get next message to parse */</span></span><br><span class="line">        nmsg = conn-&gt;recv_next(ctx, conn, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (nmsg == <span class="literal">NULL</span> || nmsg == msg) &#123;</span><br><span class="line">            <span class="comment">/* no more data to parse */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg = nmsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NC_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">``` c</span><br><span class="line"><span class="type">static</span> <span class="type">rstatus_t</span></span><br><span class="line"><span class="title function_">msg_parse</span><span class="params">(<span class="keyword">struct</span> context *ctx, <span class="keyword">struct</span> conn *conn, <span class="keyword">struct</span> msg *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rstatus_t</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg_empty(msg)) &#123;</span><br><span class="line">        <span class="comment">/* no data to parse */</span></span><br><span class="line">        conn-&gt;recv_done(ctx, conn, msg, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> NC_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// msg对redis或memcache的实际命令处理函数</span></span><br><span class="line">    msg-&gt;parser(msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;result) &#123;</span><br><span class="line">    <span class="comment">// 成功解析完了一条命令</span></span><br><span class="line">    <span class="keyword">case</span> MSG_PARSE_OK:</span><br><span class="line">        status = msg_parsed(ctx, conn, msg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 成功解析完了一条命令，但该命令后mbuf中还有剩余字节，把它移动到一个新mbuf中，并插入msg链表</span></span><br><span class="line">    <span class="keyword">case</span> MSG_PARSE_REPAIR:</span><br><span class="line">        status = msg_repair(ctx, conn, msg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 一条消息没有接收完，啥也不做，直接退出，等待tcp读到一个命令的全部字节再处理</span></span><br><span class="line">    <span class="keyword">case</span> MSG_PARSE_AGAIN:</span><br><span class="line">        status = NC_OK;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        status = NC_ERROR;</span><br><span class="line">        conn-&gt;err = errno;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> conn-&gt;err != <span class="number">0</span> ? NC_ERROR : status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是msg-&gt;parser(msg)对应的redis函数，在msg_get中被绑定</span></span><br><span class="line"><span class="keyword">struct</span> msg *</span><br><span class="line"><span class="title function_">msg_get</span><span class="params">(<span class="keyword">struct</span> conn *conn, <span class="type">bool</span> request, <span class="type">bool</span> redis)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    msg = _msg_get();</span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg-&gt;owner = conn;</span><br><span class="line">    msg-&gt;request = request ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    msg-&gt;redis = redis ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (redis) &#123;</span><br><span class="line">        <span class="keyword">if</span> (request) &#123;</span><br><span class="line">            msg-&gt;parser = redis_parse_req;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg-&gt;parser = redis_parse_rsp;</span><br><span class="line">        &#125;</span><br><span class="line">        msg-&gt;add_auth = redis_add_auth;</span><br><span class="line">        msg-&gt;fragment = redis_fragment;</span><br><span class="line">        msg-&gt;reply = redis_reply;</span><br><span class="line">        msg-&gt;failure = redis_failure;</span><br><span class="line">        msg-&gt;pre_coalesce = redis_pre_coalesce;</span><br><span class="line">        msg-&gt;post_coalesce = redis_post_coalesce;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...memcache...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">redis_parse_req</span><span class="params">(<span class="keyword">struct</span> msg *r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// redis协议处理</span></span><br><span class="line">    <span class="comment">// 状态机模型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一条命令解析完毕后，执行<code>req_recv_done</code>，先对命令做基本的判断与过滤后，再判断是否要切分成多段命令用于转发给不同的redis-server,对每段执行req_forward。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">req_recv_done</span><span class="params">(<span class="keyword">struct</span> context *ctx, <span class="keyword">struct</span> conn *conn, <span class="keyword">struct</span> msg *msg,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> msg *nmsg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rstatus_t</span> status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">server_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_tqh</span> <span class="title">frag_msgq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">sub_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">tmsg</span>;</span> 			<span class="comment">/* tmp next message */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enqueue next message (request), if any */</span></span><br><span class="line">    conn-&gt;rmsg = nmsg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (req_filter(conn, msg)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;noforward) &#123;</span><br><span class="line">        status = req_make_reply(ctx, conn, msg);</span><br><span class="line">        <span class="keyword">if</span> (status != NC_OK) &#123;</span><br><span class="line">            conn-&gt;err = errno;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        status = msg-&gt;reply(msg);</span><br><span class="line">        <span class="keyword">if</span> (status != NC_OK) &#123;</span><br><span class="line">            conn-&gt;err = errno;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 触发写事件，因无需转发</span></span><br><span class="line">        status = event_add_out(ctx-&gt;evb, conn);</span><br><span class="line">        <span class="keyword">if</span> (status != NC_OK) &#123;</span><br><span class="line">            conn-&gt;err = errno;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* do fragment */</span></span><br><span class="line">    pool = conn-&gt;owner;</span><br><span class="line">    TAILQ_INIT(&amp;frag_msgq);</span><br><span class="line">    <span class="comment">// 将一条完整的命令分段，用于发给不同的redis-server</span></span><br><span class="line">    status = msg-&gt;fragment(msg, array_n(&amp;pool-&gt;server), &amp;frag_msgq);</span><br><span class="line">    <span class="keyword">if</span> (status != NC_OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!msg-&gt;noreply) &#123;</span><br><span class="line">            conn-&gt;enqueue_outq(ctx, conn, msg);</span><br><span class="line">        &#125;</span><br><span class="line">        req_forward_error(ctx, conn, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if no fragment happened */</span></span><br><span class="line">    <span class="keyword">if</span> (TAILQ_EMPTY(&amp;frag_msgq)) &#123;</span><br><span class="line">        req_forward(ctx, conn, msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这一步将这个req做了一个rsp放入了该client-conn的outq里面</span></span><br><span class="line">    status = req_make_reply(ctx, conn, msg);</span><br><span class="line">    <span class="keyword">if</span> (status != NC_OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!msg-&gt;noreply) &#123;</span><br><span class="line">            conn-&gt;enqueue_outq(ctx, conn, msg);</span><br><span class="line">        &#125;</span><br><span class="line">        req_forward_error(ctx, conn, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对每个分段msg分发给不同的redis后端</span></span><br><span class="line">    <span class="keyword">for</span> (sub_msg = TAILQ_FIRST(&amp;frag_msgq); sub_msg != <span class="literal">NULL</span>; sub_msg = tmsg) &#123;</span><br><span class="line">        tmsg = TAILQ_NEXT(sub_msg, m_tqe);</span><br><span class="line"></span><br><span class="line">        TAILQ_REMOVE(&amp;frag_msgq, sub_msg, m_tqe);</span><br><span class="line">        req_forward(ctx, conn, sub_msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ASSERT(TAILQ_EMPTY(&amp;frag_msgq));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">req_forward</span><span class="params">(<span class="keyword">struct</span> context *ctx, <span class="keyword">struct</span> conn *c_conn, <span class="keyword">struct</span> msg *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rstatus_t</span> status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn</span> *<span class="title">s_conn</span>;</span></span><br><span class="line">    <span class="type">uint8_t</span> *key;</span><br><span class="line">    <span class="type">uint32_t</span> keylen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">keypos</span> *<span class="title">kpos</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enqueue message (request) into client outq, if response is expected */</span></span><br><span class="line">    <span class="keyword">if</span> (!msg-&gt;noreply) &#123;</span><br><span class="line">        c_conn-&gt;enqueue_outq(ctx, c_conn, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kpos = array_get(msg-&gt;keys, <span class="number">0</span>);</span><br><span class="line">    key = kpos-&gt;start;</span><br><span class="line">    keylen = (<span class="type">uint32_t</span>)(kpos-&gt;end - kpos-&gt;start);</span><br><span class="line">    <span class="comment">// 获取一个与对应server关联的conn</span></span><br><span class="line">    s_conn = server_pool_conn(ctx, c_conn-&gt;owner, key, keylen);</span><br><span class="line">    <span class="keyword">if</span> (s_conn == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Handle a failure to establish a new connection to a server,</span></span><br><span class="line"><span class="comment">         * e.g. due to dns resolution errors.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * If this is a fragmented request sent to multiple servers such as</span></span><br><span class="line"><span class="comment">         * a memcache get(multiget),</span></span><br><span class="line"><span class="comment">         * mark the fragment for this request to the server as done.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Normally, this would be done when the request was forwarded to the</span></span><br><span class="line"><span class="comment">         * server, but due to failing to connect to the server this check is</span></span><br><span class="line"><span class="comment">         * repeated here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;frag_owner != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            msg-&gt;frag_owner-&gt;nfrag_done++;</span><br><span class="line">        &#125;</span><br><span class="line">        req_forward_error(ctx, c_conn, msg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* enqueue the message (request) into server inq */</span></span><br><span class="line">    <span class="comment">// 如果之前server-conn队列全部都处理完毕了，那么需要触发套接字写事件</span></span><br><span class="line">    <span class="keyword">if</span> (TAILQ_EMPTY(&amp;s_conn-&gt;imsg_q)) &#123;</span><br><span class="line">        status = event_add_out(ctx-&gt;evb, s_conn);</span><br><span class="line">        <span class="keyword">if</span> (status != NC_OK) &#123;</span><br><span class="line">            req_forward_error(ctx, c_conn, msg);</span><br><span class="line">            s_conn-&gt;err = errno;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将其插入对应server-conn的enqueue队尾</span></span><br><span class="line">    s_conn-&gt;enqueue_inq(ctx, s_conn, msg);</span><br><span class="line"></span><br><span class="line">    req_forward_stats(ctx, s_conn-&gt;owner, msg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="twemproxy发送请求给redis"><a href="#twemproxy发送请求给redis" class="headerlink" title="twemproxy发送请求给redis"></a>twemproxy发送请求给redis</h4><p>因为之前触发了server_conn的写事件，因此会触发写回调函数，该回调函数负责将enqueue的msg逐个发给redis</p>
<p>msg_send无特别处理，循环发完全部msg消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rstatus_t</span></span><br><span class="line"><span class="title function_">msg_send</span><span class="params">(<span class="keyword">struct</span> context *ctx, <span class="keyword">struct</span> conn *conn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rstatus_t</span> status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    conn-&gt;send_ready = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        msg = conn-&gt;send_next(ctx, conn);</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* nothing to send */</span></span><br><span class="line">            <span class="keyword">return</span> NC_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        status = msg_send_chain(ctx, conn, msg);</span><br><span class="line">        <span class="keyword">if</span> (status != NC_OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (conn-&gt;send_ready);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NC_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个函数只是做了从imsg_q中取出一个msg的工作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg *</span><br><span class="line"><span class="title function_">req_send_next</span><span class="params">(<span class="keyword">struct</span> context *ctx, <span class="keyword">struct</span> conn *conn)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">rstatus_t</span> status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg</span>, *<span class="title">nmsg</span>;</span> <span class="comment">/* current and next message */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;connecting) &#123;</span><br><span class="line">        server_connected(ctx, conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nmsg = TAILQ_FIRST(&amp;conn-&gt;imsg_q);</span><br><span class="line">    <span class="keyword">if</span> (nmsg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* nothing to send as the server inq is empty */</span></span><br><span class="line">        status = event_del_out(ctx-&gt;evb, conn);</span><br><span class="line">        <span class="keyword">if</span> (status != NC_OK) &#123;</span><br><span class="line">            conn-&gt;err = errno;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg = conn-&gt;smsg;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ASSERT(msg-&gt;request &amp;&amp; !msg-&gt;done);</span><br><span class="line">        nmsg = TAILQ_NEXT(msg, s_tqe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conn-&gt;smsg = nmsg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nmsg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> nmsg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将imsg_q的msg放到临时变量send_msgq里面，用unix-api的<code>sendv()</code>批量发送，最多一次可以发送<code>NC_IOV_MAX</code>块的数量（无论多少个msg）。对于每一个发送完毕的msg，调用<code>conn-&gt;send_done(ctx, conn, msg)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">rstatus_t</span></span><br><span class="line"><span class="title function_">msg_send_chain</span><span class="params">(<span class="keyword">struct</span> context *ctx, <span class="keyword">struct</span> conn *conn, <span class="keyword">struct</span> msg *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_tqh</span> <span class="title">send_msgq</span>;</span>            <span class="comment">/* send msg q */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">nmsg</span>;</span>                    <span class="comment">/* next msg */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">mbuf</span>, *<span class="title">nbuf</span>;</span>            <span class="comment">/* current and next mbuf */</span></span><br><span class="line">    <span class="type">size_t</span> mlen;                         <span class="comment">/* current mbuf data length */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">ciov</span>, <span class="title">iov</span>[<span class="title">NC_IOV_MAX</span>];</span> <span class="comment">/* current iovec */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">array</span> <span class="title">sendv</span>;</span>                  <span class="comment">/* send iovec */</span></span><br><span class="line">    <span class="type">size_t</span> nsend, nsent;                 <span class="comment">/* bytes to send; bytes sent */</span></span><br><span class="line">    <span class="type">size_t</span> limit;                        <span class="comment">/* bytes to send limit */</span></span><br><span class="line">    <span class="type">ssize_t</span> n;                           <span class="comment">/* bytes sent by sendv */</span></span><br><span class="line"></span><br><span class="line">    TAILQ_INIT(&amp;send_msgq);</span><br><span class="line"></span><br><span class="line">    array_set(&amp;sendv, iov, <span class="keyword">sizeof</span>(iov[<span class="number">0</span>]), NC_IOV_MAX);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* preprocess - build iovec */</span></span><br><span class="line"></span><br><span class="line">    nsend = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * readv() and writev() returns EINVAL if the sum of the iov_len values</span></span><br><span class="line"><span class="comment">     * overflows an ssize_t value Or, the vector count iovcnt is less than</span></span><br><span class="line"><span class="comment">     * zero or greater than the permitted maximum.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    limit = SSIZE_MAX;</span><br><span class="line">    <span class="comment">// 批处理收集过程</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ASSERT(conn-&gt;smsg == msg);</span><br><span class="line"></span><br><span class="line">        TAILQ_INSERT_TAIL(&amp;send_msgq, msg, m_tqe);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (mbuf = STAILQ_FIRST(&amp;msg-&gt;mhdr);</span><br><span class="line">             mbuf != <span class="literal">NULL</span> &amp;&amp; array_n(&amp;sendv) &lt; NC_IOV_MAX &amp;&amp; nsend &lt; limit;</span><br><span class="line">             mbuf = nbuf) &#123;</span><br><span class="line">            nbuf = STAILQ_NEXT(mbuf, next);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mbuf_empty(mbuf)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mlen = mbuf_length(mbuf);</span><br><span class="line">            <span class="keyword">if</span> ((nsend + mlen) &gt; limit) &#123;</span><br><span class="line">                mlen = limit - nsend;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ciov = array_push(&amp;sendv);</span><br><span class="line">            ciov-&gt;iov_base = mbuf-&gt;pos;</span><br><span class="line">            ciov-&gt;iov_len = mlen;</span><br><span class="line"></span><br><span class="line">            nsend += mlen;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (array_n(&amp;sendv) &gt;= NC_IOV_MAX || nsend &gt;= limit) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg = conn-&gt;send_next(ctx, conn);</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直到这里收集完全部需要发送的数据，开始发送</span></span><br><span class="line">    conn-&gt;smsg = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!TAILQ_EMPTY(&amp;send_msgq) &amp;&amp; nsend != <span class="number">0</span>) &#123;</span><br><span class="line">        n = conn_sendv(conn, &amp;sendv, nsend);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nsent = n &gt; <span class="number">0</span> ? (<span class="type">size_t</span>)n : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* postprocess - process sent messages in send_msgq */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (msg = TAILQ_FIRST(&amp;send_msgq); msg != <span class="literal">NULL</span>; msg = nmsg) &#123;</span><br><span class="line">        nmsg = TAILQ_NEXT(msg, m_tqe);</span><br><span class="line"></span><br><span class="line">        TAILQ_REMOVE(&amp;send_msgq, msg, m_tqe);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nsent == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg-&gt;mlen == <span class="number">0</span>) &#123;</span><br><span class="line">                conn-&gt;send_done(ctx, conn, msg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* adjust mbufs of the sent message */</span></span><br><span class="line">        <span class="keyword">for</span> (mbuf = STAILQ_FIRST(&amp;msg-&gt;mhdr); mbuf != <span class="literal">NULL</span>; mbuf = nbuf) &#123;</span><br><span class="line">            nbuf = STAILQ_NEXT(mbuf, next);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mbuf_empty(mbuf)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mlen = mbuf_length(mbuf);</span><br><span class="line">            <span class="keyword">if</span> (nsent &lt; mlen) &#123;</span><br><span class="line">                <span class="comment">/* mbuf was sent partially; process remaining bytes later */</span></span><br><span class="line">                mbuf-&gt;pos += nsent;</span><br><span class="line">                ASSERT(mbuf-&gt;pos &lt; mbuf-&gt;last);</span><br><span class="line">                nsent = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* mbuf was sent completely; mark it empty */</span></span><br><span class="line">            mbuf-&gt;pos = mbuf-&gt;last;</span><br><span class="line">            nsent -= mlen;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* message has been sent completely, finalize it */</span></span><br><span class="line">        <span class="keyword">if</span> (mbuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            conn-&gt;send_done(ctx, conn, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ASSERT(TAILQ_EMPTY(&amp;send_msgq));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NC_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (n == NC_EAGAIN) ? NC_OK : NC_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每一个发送完毕的msg操作比较简单，只需要从imsg_q中出队即可，出队后则不会在下次循环中被遍历到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">req_send_done</span><span class="params">(<span class="keyword">struct</span> context *ctx, <span class="keyword">struct</span> conn *conn, <span class="keyword">struct</span> msg *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dequeue the message (request) from server inq */</span></span><br><span class="line">    conn-&gt;dequeue_inq(ctx, conn, msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * noreply request instructs the server not to send any response. So,</span></span><br><span class="line"><span class="comment">     * enqueue message (request) in server outq, if response is expected.</span></span><br><span class="line"><span class="comment">     * Otherwise, free the noreply request</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 对于需要等待回复的命令，将这个msg记录在outq队列里，这里的out指outstanding,可以理解为一种特殊标记，这个msg与client的outq的msg相对应，之后用于找到client的outq对应的msg用于回复用户侧信息</span></span><br><span class="line">    <span class="keyword">if</span> (!msg-&gt;noreply) &#123;</span><br><span class="line">        conn-&gt;enqueue_outq(ctx, conn, msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 直接释放</span></span><br><span class="line">        req_put(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redis回复与发回用户侧"><a href="#redis回复与发回用户侧" class="headerlink" title="redis回复与发回用户侧"></a>redis回复与发回用户侧</h4><p>代码逻辑几乎一模一样，这里后续不详细阐述了。可以根据<a href="#%E9%A1%B9%E7%9B%AE%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%9E%B6%E6%9E%84">项目网络编程架构</a>自由的阅读剩下代码。</p>
<p>比较值得关注的是<code>rsp_recv_done</code>到<code>rsp_forward</code>，如何建立client_conn与server_conn之间msg的联系的，是通过<code>peer</code>变量。后续基本就是围绕outstanding_q在做相关的操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* establish msg &lt;-&gt; pmsg (response &lt;-&gt; request) link */</span></span><br><span class="line">pmsg-&gt;peer = msg;</span><br><span class="line">msg-&gt;peer = pmsg;</span><br></pre></td></tr></table></figure>


<h2 id="mbuf模块"><a href="#mbuf模块" class="headerlink" title="mbuf模块"></a>mbuf模块</h2><h2 id="临时笔记"><a href="#临时笔记" class="headerlink" title="临时笔记"></a>临时笔记</h2><p>client和proxy连接的owner为server_pool</p>
<p>server连接的owner为对应的server，对应server的owner为对应的server_pool。</p>
<p>每一个message在分配时会指定其相关的处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg *</span><br><span class="line"><span class="title function_">msg_get</span><span class="params">(<span class="keyword">struct</span> conn *conn, <span class="type">bool</span> request, <span class="type">bool</span> redis)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    msg = _msg_get();</span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg-&gt;owner = conn;</span><br><span class="line">    msg-&gt;request = request ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    msg-&gt;redis = redis ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (redis) &#123;</span><br><span class="line">        <span class="keyword">if</span> (request) &#123;</span><br><span class="line">            msg-&gt;parser = redis_parse_req;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg-&gt;parser = redis_parse_rsp;</span><br><span class="line">        &#125;</span><br><span class="line">        msg-&gt;add_auth = redis_add_auth;</span><br><span class="line">        msg-&gt;fragment = redis_fragment;</span><br><span class="line">        msg-&gt;reply = redis_reply;</span><br><span class="line">        msg-&gt;failure = redis_failure;</span><br><span class="line">        msg-&gt;pre_coalesce = redis_pre_coalesce;</span><br><span class="line">        msg-&gt;post_coalesce = redis_post_coalesce;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request) &#123;</span><br><span class="line">            msg-&gt;parser = memcache_parse_req;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg-&gt;parser = memcache_parse_rsp;</span><br><span class="line">        &#125;</span><br><span class="line">        msg-&gt;add_auth = memcache_add_auth;</span><br><span class="line">        msg-&gt;fragment = memcache_fragment;</span><br><span class="line">        msg-&gt;failure = memcache_failure;</span><br><span class="line">        msg-&gt;pre_coalesce = memcache_pre_coalesce;</span><br><span class="line">        msg-&gt;post_coalesce = memcache_post_coalesce;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log_loggable(LOG_NOTICE) != <span class="number">0</span>) &#123;</span><br><span class="line">        msg-&gt;start_ts = nc_usec_now();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_debug(LOG_VVERB, <span class="string">&quot;get msg %p id %&quot;</span>PRIu64<span class="string">&quot; request %d owner sd %d&quot;</span>,</span><br><span class="line">              msg, msg-&gt;id, msg-&gt;request, conn-&gt;sd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/project/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/project/">1</a><a class="page-number" href="/project/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/project/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/project/page/8/">8</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/project/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Corgis</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/project/js/comments.js"></script><script src="/project/js/utils.js"></script><script src="/project/js/motion.js"></script><script src="/project/js/sidebar.js"></script><script src="/project/js/next-boot.js"></script>

  






  





</body>
</html>
