<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/corgis.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/corgis.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"scut-corgis.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="用于成长过程中，记录值得对外分享的技术，如开源代码理解、国外课程项目，个人对一些领域的心得等">
<meta property="og:type" content="website">
<meta property="og:title" content="corgis的笔记">
<meta property="og:url" content="https://scut-corgis.github.io/page/16/index.html">
<meta property="og:site_name" content="corgis的笔记">
<meta property="og:description" content="用于成长过程中，记录值得对外分享的技术，如开源代码理解、国外课程项目，个人对一些领域的心得等">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Corgis">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://scut-corgis.github.io/page/16/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/16/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>corgis的笔记</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">corgis的笔记</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Corgis"
      src="/images/corgis.jpg">
  <p class="site-author-name" itemprop="name">Corgis</p>
  <div class="site-description" itemprop="description">用于成长过程中，记录值得对外分享的技术，如开源代码理解、国外课程项目，个人对一些领域的心得等</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://scut-corgis.github.io/2024-11-25-%E5%BF%AB%E6%89%8B%E6%8C%91%E6%88%98%E8%B5%9B-Rpc%E8%87%AA%E9%80%82%E5%BA%94%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/corgis.jpg">
      <meta itemprop="name" content="Corgis">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="corgis的笔记">
      <meta itemprop="description" content="用于成长过程中，记录值得对外分享的技术，如开源代码理解、国外课程项目，个人对一些领域的心得等">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | corgis的笔记">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024-11-25-%E5%BF%AB%E6%89%8B%E6%8C%91%E6%88%98%E8%B5%9B-Rpc%E8%87%AA%E9%80%82%E5%BA%94%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">快手挑战赛-Rpc自适应负载均衡实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-11-25 21:30:05" itemprop="dateCreated datePublished" datetime="2024-11-25T21:30:05+08:00">2024-11-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/kuaishou/" itemprop="url" rel="index"><span itemprop="name">kuaishou</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在加入快手后的第4个月，快手举行了一次技术比赛，4个大部门共同参加，最终参加人数70人，开发时间一个月。我参加了这次比赛，在开发和研究这个赛题的过程中，收益良多，成长很大。</p>
<p>比赛使得我对顶层服务、负载均衡架构进行了较深入的探索，也全程让自己去单独开发服务，去找开源库，去对比开源库算法，并让我意识到go的标准库的性能原来并没有做到最优，甚至是比起第三方库实现还很差。</p>
<p>再者，比赛逼着我去研究<strong>go汇编</strong>，去研究<strong>avx指令集</strong>，让我学习到了avx指令集的强大，我艰难的完成了手写avx汇编代码，并完全靠自己写了一个极为优化版本的汇编sha256实现。这个过程很难，但是看到性能得到了相当的提升后（核心sha256优化提升了近20%的性能），我感到空前的自豪与满足。</p>
<p>最终比赛拿了三等奖（第五名），虽然我觉得我应该是前二，因为前三名抱团团战，都找到了一个十分冷门的用avx512指令实现的sha256库。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Scut-Corgis/banlance-competation">github代码仓库</a></p>
<p><img src="/2024-11-25-%E5%BF%AB%E6%89%8B%E6%8C%91%E6%88%98%E8%B5%9B-Rpc%E8%87%AA%E9%80%82%E5%BA%94%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0/%E5%A5%96%E7%8A%B6.jpg"></p>
<h1 id="赛题介绍"><a href="#赛题介绍" class="headerlink" title="赛题介绍"></a>赛题介绍</h1><h2 id="赛事背景"><a href="#赛事背景" class="headerlink" title="赛事背景"></a>赛事背景</h2><p>公司采购的服务器当中，不同批次或型号的机器之间存在明显性能差异，导致业务服务处理等量QPS的前端请求时，所需的CPU资源呈现出明显的不均衡。这种CPU使用率的差异性，进一步加剧了整体运营成本的压力，特别是在流量激增时，更可能引发稳定性问题，影响服务的连续性和可靠性。</p>
<p>为应对这一挑战，我们期望研发一种高效的服务调度策略，根据机器的实际计算能力，实现全局的Rpc自适应负载均衡。这一机制的核心在于，能够智能地识别并响应不同性能表现的服务器实例，通过动态调整请求分配，确保各实例的CPU使用率维持在一个相对均衡的水平上。在保持总机器成本不变的前提下，提供尽可能多的算力。同时，需确保服务响应延时满足既定的业务要求。</p>
<h2 id="赛题信息"><a href="#赛题信息" class="headerlink" title="赛题信息"></a>赛题信息</h2><p><img src="/2024-11-25-%E5%BF%AB%E6%89%8B%E6%8C%91%E6%88%98%E8%B5%9B-Rpc%E8%87%AA%E9%80%82%E5%BA%94%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0/%E8%B5%9B%E9%A2%98%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%9B%BE.png"></p>
<p>题目要求：参赛选手基于社区版gRPC（支持C++、Java、Golang）实现Rpc client（服务A）和Rpc server（服务B），主办方发压机向服务A发送HTTP请求，请求中包含一个字符串Str和需要循环计算算法次数Num（循环计算：指前一次输出结果字符串作为后一次输入，循环计算），服务A将请求转发到服务B后，服务B需循环计算Str对应的 “SHA-2 256” 值，并返回处理结果给发压机。发压机会对整体响应时间和整体响应正确性进行记录，作为最终排名依据。</p>
<p>参赛选手需着重实现服务B的负载均衡功能，灵活调整服务注册和服务发现策略，确保客户端请求服务端可实现自适应负载均衡。程序应具备以下特性：</p>
<ol>
<li>根据实际服务压力情况，动态调整服务A、服务B的线程池、队列大小等参数，追求更高的全局处理能力，以及处理成功率</li>
<li>发压机统一设置HTTP响应超时时间为1s</li>
<li>主办方提供测试数据文件，发压机从文件逐行获取请求内容，并轮询发给服务A的各个节点</li>
<li>服务A和服务B所需机器均从容器云申请（容器规格由主办方指定），服务A实例数量为3个，服务B实例数量为10个（容器规格：4c4g）</li>
<li>服务A和服务B之间通过gRPC交互</li>
<li>服务B响应服务A的Rpc调用，并将结果返回给服务A</li>
</ol>
<p>服务A的接口方式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST</span><br><span class="line">https<span class="punctuation">:</span><span class="comment">//xxxxxx.staging.kuaishou.com/sha256/calc</span></span><br><span class="line"></span><br><span class="line">请求body：</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;inputValue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;KSChallenge2024&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;number&quot;</span><span class="punctuation">:</span> <span class="number">10000</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">响应body：</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;resultValue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;90f9c4fc3bab9e588a2f5b62097438e798755e2eab5bff346fa528652b709457&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="评测方式"><a href="#评测方式" class="headerlink" title="评测方式"></a>评测方式</h2><p>在比赛开始前，参赛方可以使用主办方提供的公开压测数据集或自拟数据集，进行测试验证。<br>最终比赛结果以主办方发起的压测验证结果为准。</p>
<p>评判规则</p>
<ul>
<li>请求失败数：发压机向服务A发送等量HTTP请求，每次请求未得到预期结果则失败数加1</li>
<li>实际处理时长：发压机开始发送第一次HTTP请求记T1，收到最后一次HTTP请求的返回结果记T2，实际处理时长 &#x3D; T2 - T1，单位s，精确到小数点后3位</li>
<li>最终用时：每失败一次则罚时1秒，即最终用时 &#x3D; 实际处理时长 + 请求失败数 * 1s。根据“最终用时”对选手进行排名，用时短的排名靠前</li>
</ul>
<p>示例：<br>假设发压机向服务A发送了100万次HTTP请求，总耗时为20秒。其中有3次请求未能达到预期结果，则最终的总耗时为：20秒加上3次请求的额外时间，总计为23秒。</p>
<h1 id="我的实现"><a href="#我的实现" class="headerlink" title="我的实现"></a>我的实现</h1><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>在实现服务A和服务B的过程中，我迭代了数个版本，出了数个方案。我总结出了以下经验：</p>
<ol>
<li><p>B作为CPU密集型的服务，不要处理除了计算以外的任何逻辑，比如不要上报，不要有锁争用，需要充分的利用cpu，并且将cpu完全的倾斜在计算上面。</p>
</li>
<li><p>轮询+限流（或熔断）能够打败绝大多数的均衡算法，即使对于特定场景优化了均衡算法，也不会取得太高的优化提升。</p>
</li>
<li><p>A作为转发服务，因为其无法获得B的上报监控信息，那么只能从自身A服务中获取，则实时性是最重要的，尽可能通过交互获取B实时负载是一大难点。</p>
</li>
<li><p>优化cpu密集型的核心算法，收益永远是最高的。</p>
</li>
</ol>
<h2 id="负载均衡实现"><a href="#负载均衡实现" class="headerlink" title="负载均衡实现"></a>负载均衡实现</h2><p>既然B不能作为上报，A又要获取实时的B负载信息，成为了一大难点。我的负载均衡方案如下：</p>
<p>A服务之间互相维护一条连接，即互相也做zk的服务发现和服务注册，在转发sha256算法给B服务前，告知其他A服务有这样一条请求存在，使得其他A服务能够维护当前所有B正在处理的请求列表，在收到B服务应答后，再广播告诉其他A这条请求已经结束。</p>
<p>因此所有A的示例都能维护一个列表，记录了每个B示例的请求数，因此可以用这个做转发的判断依据，我的算法是<strong>最小循环次数优先</strong>，即哪个B实例循环计算次数和最小，就转发给谁。</p>
<p>当然，我们应该做好安全措施，防止外部压测qps太大，因此我增加了熔断，保证某个B服务1秒后没回复，则熔断该服务一定时间。同时我也做了重试，以防止某个过载而其他空闲，使得一个请求本身可以处理而没法处理的情况。</p>
<p>下面的核心代码基本能够说明整个算法思路</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span></span> Sha256ReqForward(req <span class="type">string</span>, num <span class="type">int</span>) (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 最多选3次, 防止部分过载</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		node := c.Wr.Choose()</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">		conn, err := c.ClientPools[node].getConn()</span><br><span class="line">        ...</span><br><span class="line">		bcli := apiB.NewBClient(conn)</span><br><span class="line"></span><br><span class="line">		ctx, _ := context.WithTimeout(context.Background(), requestTimeout)</span><br><span class="line">		<span class="keyword">go</span> clientA.NewClient().SendComputeTimesChange(node, num)</span><br><span class="line">		c.Wr.UpdateNodeReqNum(node, num)</span><br><span class="line">        <span class="comment">// 真正转发给B实例的位置</span></span><br><span class="line">		r, err := bcli.ComputeSha256(ctx, &amp;apiB.Sha256Request&#123;ShaReq: req, Num: <span class="type">int32</span>(num)&#125;)</span><br><span class="line"></span><br><span class="line">		c.Wr.UpdateNodeReqNum(node, num*(<span class="number">-1</span>))</span><br><span class="line">		<span class="keyword">go</span> clientA.NewClient().SendComputeTimesChange(node, num*(<span class="number">-1</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 熔断</span></span><br><span class="line">			c.Wr.UpdateNodeColdTime(node, time.Now().Add(coldInterval).Unix())</span><br><span class="line">			<span class="comment">// 重试</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> r.GetShaResp(), <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	log.Error().Msg(<span class="string">&quot;三次尝试均失败了&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, errors.New(<span class="string">&quot;三次尝试均失败了&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即真正转发前，开一个并发协程告知其他A实例增加某个B节点的循环次数，结束后再告知减少。</p>
<p>最小请求数选择的核心过程相当简单</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wr *WeightedRandom)</span></span> MinReqNumChoice() *Node &#123;</span><br><span class="line">	sort.Sort(ByReqNum(wr.Nodes))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(wr.Nodes); i++ &#123;</span><br><span class="line">        <span class="comment">// 熔断</span></span><br><span class="line">		<span class="keyword">if</span> wr.Nodes[i].ColdTime &gt; time.Now().Unix() &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> wr.Nodes[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//log.Warn().Msg(&quot;randomChoice失败, 可能是全部节点冷却&quot;)</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>负载均衡算法的提升</strong></p>
<p>有趣的是，这个方案是我探索了很多方案都打不过轮询后(如随机，加权随机，最小任务数优先，B上报等等)，赢了轮询的方案，但是也只有3% - 4%的性能提升。</p>
<h2 id="SHA256循环计算优化"><a href="#SHA256循环计算优化" class="headerlink" title="SHA256循环计算优化"></a>SHA256循环计算优化</h2><p>当我意识到负载均衡根本不是关键的时候，我将目光转向了这个循环算法，也证实了，每优化一点循环算法，带来的收益是巨大的。</p>
<h3 id="基于标准库"><a href="#基于标准库" class="headerlink" title="基于标准库"></a>基于标准库</h3><p>首先，作为最朴素的想法，可能会如下实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoMultiSha256_2</span><span class="params">(req <span class="type">string</span>, times <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// 将初始字符串转换为字节切片</span></span><br><span class="line">	curStr := req</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; times; i++ &#123;</span><br><span class="line">		curStr = ComputerSha256Core(curStr)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> curStr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ComputerSha256Core</span><span class="params">(req <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// 计算 SHA-256 哈希值</span></span><br><span class="line">	hash := sha256.New()</span><br><span class="line">	hash.Write([]<span class="type">byte</span>(req))</span><br><span class="line">	hashBytes := hash.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将哈希值转为十六进制字符串</span></span><br><span class="line">	rsp := hex.EncodeToString(hashBytes)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rsp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这种写法性能是最差的，首先在高循环次数时，函数调用次数非常多，再者，涉及了大量的堆垃圾，使得go的垃圾回收相当频繁。</p>
<p>这里直接给出，使用go标准库的情况下，且安全的情况下，我认为的最佳实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoMultiSha256</span><span class="params">(req <span class="type">string</span>, times <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	hash := sha256.New()</span><br><span class="line">	<span class="comment">// 预分配一个字节切片用于存储 SHA-256 哈希结果</span></span><br><span class="line">	hashBytes := <span class="built_in">make</span>([]<span class="type">byte</span>, sha256.Size)</span><br><span class="line">	<span class="comment">// 预分配一个字节切片用于存储十六进制字符串的字节</span></span><br><span class="line">	hexBytes := <span class="built_in">make</span>([]<span class="type">byte</span>, hex.EncodedLen(<span class="built_in">len</span>(hashBytes)))</span><br><span class="line"></span><br><span class="line">	curbytes := []<span class="type">byte</span>(req)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; times; i++ &#123;</span><br><span class="line">		<span class="comment">// 计算 SHA-256 哈希值</span></span><br><span class="line">		hash.Reset()</span><br><span class="line">		hash.Write(curbytes)</span><br><span class="line">		hash.Sum(hashBytes[:<span class="number">0</span>]) <span class="comment">// 将结果写入预分配的字节切片</span></span><br><span class="line">		<span class="comment">// 将哈希值转为十六进制字符串</span></span><br><span class="line">		hex.Encode(hexBytes, hashBytes)</span><br><span class="line">		<span class="comment">// 将十六进制字符串的字节切片作为下次计算的输入</span></span><br><span class="line">		curbytes = hexBytes</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(curbytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，整个过程基本没有内存分配，都是利用的预分配内存。当然，假如再进一步，甚至可以继续优化</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoMultiSha256_4</span><span class="params">(req <span class="type">string</span>, times <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// 预分配一个字节切片用于存储 SHA-256 哈希结果</span></span><br><span class="line">	hashBytes := <span class="built_in">make</span>([]<span class="type">byte</span>, sha256.Size)</span><br><span class="line">	<span class="comment">// 预分配一个字节切片用于存储十六进制字符串的字节</span></span><br><span class="line">	hexBytes := <span class="built_in">make</span>([]<span class="type">byte</span>, hex.EncodedLen(<span class="built_in">len</span>(hashBytes)))</span><br><span class="line"></span><br><span class="line">	curBytes := []<span class="type">byte</span>(req)</span><br><span class="line">	<span class="keyword">var</span> res [sha256.Size]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 预先创建一个切片头，可以反复使用</span></span><br><span class="line">	resSlice := unsafe.Slice((*<span class="type">byte</span>)(unsafe.Pointer(&amp;res[<span class="number">0</span>])), sha256.Size)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; times; i++ &#123;</span><br><span class="line">		<span class="comment">// 计算 SHA-256 的哈希值，结果为数组类型</span></span><br><span class="line">		res = sha256.Sum256(curBytes)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将哈希值转为十六进制字符串</span></span><br><span class="line">		hex.Encode(hexBytes, resSlice)</span><br><span class="line">		<span class="comment">// 使用十六进制字符串作为下一次计算的输入</span></span><br><span class="line">		curBytes = hexBytes</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(curBytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即节省了拷贝消耗，但实测基本性能没有区别了。</p>
<h3 id="优化hex"><a href="#优化hex" class="headerlink" title="优化hex"></a>优化hex</h3><p>当我进一步分析，打印pprof的火焰图，看看B服务哪里是性能瓶颈，我发现了如下结论</p>
<p><img src="/2024-11-25-%E5%BF%AB%E6%89%8B%E6%8C%91%E6%88%98%E8%B5%9B-Rpc%E8%87%AA%E9%80%82%E5%BA%94%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0/hex%E6%A0%87%E5%87%86%E5%BA%93.png"></p>
<p>hex标准库太慢了，竟然占用了10%的cpu，这是不可接受的。</p>
<p>因此我去研究标准库的实现，却发现其实现没有任何问题，已经是最优了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hextable = <span class="string">&quot;0123456789abcdef&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(dst, src []<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	j := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> src &#123;</span><br><span class="line">		dst[j] = hextable[v&gt;&gt;<span class="number">4</span>]</span><br><span class="line">		dst[j+<span class="number">1</span>] = hextable[v&amp;<span class="number">0x0f</span>]</span><br><span class="line">		j += <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(src) * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但此时我想是否有更底层的，汇编层面的优化？ 毕竟对于256位即32字节的sha256结果，在转换为16进制字符的过程中，每一个循环次数都要做32次的循环来转换，是需要去解决性能瓶颈的。</p>
<p>遗憾的是，我发现c++等语言都有更优化的实现，golang一开始我没有找到avx指令集的解法（行文顺序问题，其实此时我已经意识到了avx指令就是最优），直到我翻了许久，甚至决定自己手写的时候，我找到了一个开源库，其用了avx指令实现了转化。</p>
<p>我获取并使用了该库，取得了一定的提升，如下</p>
<p><img src="/2024-11-25-%E5%BF%AB%E6%89%8B%E6%8C%91%E6%88%98%E8%B5%9B-Rpc%E8%87%AA%E9%80%82%E5%BA%94%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0/hex%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BC%98%E5%8C%96.png"></p>
<p>然而该库为了兼容和易用性，依然使用了标准库类似的接口，使得高级语言的消耗占了大头，我进一步剔除高级语言部分，使得程序能直接进入汇编，最终将算法优化到了这样</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoMultiSha256My</span><span class="params">(req <span class="type">string</span>, times <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	hash := sha256.New()</span><br><span class="line">	<span class="comment">// 预分配一个字节切片用于存储 SHA-256 哈希结果</span></span><br><span class="line">	hashBytes := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">32</span>)</span><br><span class="line">	<span class="comment">// 预分配一个字节切片用于存储十六进制字符串的字节</span></span><br><span class="line">	hexBytes := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">64</span>)</span><br><span class="line">	curbytes := []<span class="type">byte</span>(req)</span><br><span class="line">	<span class="comment">// 计算 SHA-256 哈希值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自定义hash</span></span><br><span class="line">	myhash := sha256.New2()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; times; i++ &#123;</span><br><span class="line">		myhash.Reset()</span><br><span class="line">	    hash.Write(curbytes)</span><br><span class="line">	    hash.Sum(hashBytes[:<span class="number">0</span>]) <span class="comment">// 将结果写入预分配的字节切片</span></span><br><span class="line">	<span class="comment">// 将哈希值转为十六进制字符串</span></span><br><span class="line">	<span class="comment">//hex.Encode(hexBytes, hashBytes)</span></span><br><span class="line">	    hex2.EncodeAVX(&amp;hexBytes[<span class="number">0</span>], &amp;hashBytes[<span class="number">0</span>], <span class="number">32</span>, &amp;hex2.Lower[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将十六进制字符串的字节切片作为下次计算的输入</span></span><br><span class="line">		curbytes = hexBytes</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(curbytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即直接使用<code>EncodeAVX</code>汇编函数，节省了高级语言开销，最终优化的结果如下</p>
<p><img src="/2024-11-25-%E5%BF%AB%E6%89%8B%E6%8C%91%E6%88%98%E8%B5%9B-Rpc%E8%87%AA%E9%80%82%E5%BA%94%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0/hex%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BC%98%E5%8C%96.png"></p>
<p>因此从最开始的10%的占用，优化到了1%。对整体程序而言节省了9%的cpu，可以用于真正的sha256计算之中。</p>
<h3 id="优化sha256标准库"><a href="#优化sha256标准库" class="headerlink" title="优化sha256标准库"></a>优化sha256标准库</h3><h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h4><p>这部分优化是最艰难的，这个过程我写和改了大量的go汇编代码，也大量削减了标准库高级语言代码，使得性能得到了约5-6%的提升。</p>
<p>之所以艰难，是因为标准库已经是<strong>普遍场合</strong>的最优性能了，其已经采用了avx指令集架构，性能已经做到了极致，因此在极致上面扣细节，针对特定场景做优化难度是很大的。</p>
<p>首先，得了解sha256算法的细节，才可能找到优化思路。这里推荐两个链接，是非常好的文章和直观的表现。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94619052">https://zhuanlan.zhihu.com/p/94619052</a></p>
<p><a target="_blank" rel="noopener" href="https://sha256algorithm.com/">https://sha256algorithm.com/</a></p>
<p>链接1给出高级语言go的实现方式，能够清晰的说明整个算法过程</p>
<h4 id="特定场景优化-高级语言部分"><a href="#特定场景优化-高级语言部分" class="headerlink" title="特定场景优化 - 高级语言部分"></a>特定场景优化 - 高级语言部分</h4><p>对于当前的循环场景，很明显的特征是，除了第一次未知的输入，后面每一次输入必定是512位的字符串，刚好对应一个sha256的block。那么其后面补1，再到第二个block补长度，一定对应相同的第二个block。换句话说，一定是只有两个block，并且第二个block的值是完全不变的。</p>
<p>如图：</p>
<p><img src="/2024-11-25-%E5%BF%AB%E6%89%8B%E6%8C%91%E6%88%98%E8%B5%9B-Rpc%E8%87%AA%E9%80%82%E5%BA%94%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AE%9E%E7%8E%B0/%E6%81%92%E5%AE%9A%E7%9A%84block.png"></p>
<p>那么显然其对应的w是恒定的，因为w的计算不涉及任何的h值。所以第一个优化思路出现了，预计算w。</p>
<p>但是预计算w并不是最优，实际还能再前进一步，因为再64次循环计算h的时候，<code>w+k</code>是绑定的，所以能直接预计算<code>w+k</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//应用SHA256压缩函数更新a,b,...,h</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">64</span>; i++ &#123;</span><br><span class="line">          ...</span><br><span class="line">	temp1 := h + S1 + ch + k[i] + w[i]</span><br><span class="line">          ...</span><br><span class="line">	h = g</span><br><span class="line">	g = f</span><br><span class="line">	f = e</span><br><span class="line">	e = d + temp1</span><br><span class="line">	d = c</span><br><span class="line">	c = b</span><br><span class="line">	b = a</span><br><span class="line">	a = temp1 + temp2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此我将<code>w+k</code>的值直接预计算后，编码到了汇编中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 以下为k+w的值</span><br><span class="line">DATA KW&lt;&gt;+0x000(SB)/4, $0xc28a2f98</span><br><span class="line">DATA KW&lt;&gt;+0x004(SB)/4, $0x71374491</span><br><span class="line">...</span><br><span class="line">DATA KW&lt;&gt;+0x1f8(SB)/4, $0xa4954b68</span><br><span class="line">DATA KW&lt;&gt;+0x1fc(SB)/4, $0x4c191d76</span><br><span class="line"></span><br><span class="line">GLOBL KW&lt;&gt;(SB), (NOPTR + RODATA), $512</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先我直接给出我高级语言部分的代码，很清晰，只有第一次计算用了标准库，后面都是用的自己修改后的标准库</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoMultiSha256My</span><span class="params">(req <span class="type">string</span>, times <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	hash := sha256.New()</span><br><span class="line">	<span class="comment">// 预分配一个字节切片用于存储 SHA-256 哈希结果</span></span><br><span class="line">	hashBytes := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">32</span>)</span><br><span class="line">	<span class="comment">// 预分配一个字节切片用于存储十六进制字符串的字节</span></span><br><span class="line">	hexBytes := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">	curbytes := []<span class="type">byte</span>(req)</span><br><span class="line">	<span class="comment">// 计算 SHA-256 哈希值</span></span><br><span class="line">	hash.Write(curbytes)</span><br><span class="line">	hash.Sum(hashBytes[:<span class="number">0</span>]) <span class="comment">// 将结果写入预分配的字节切片</span></span><br><span class="line">	<span class="comment">// 将哈希值转为十六进制字符串</span></span><br><span class="line">	<span class="comment">//hex.Encode(hexBytes, hashBytes)</span></span><br><span class="line">	hex.EncodeAVX(&amp;hexBytes[<span class="number">0</span>], &amp;hashBytes[<span class="number">0</span>], <span class="number">32</span>, &amp;hex.Lower[<span class="number">0</span>])</span><br><span class="line">	<span class="comment">// 将十六进制字符串的字节切片作为下次计算的输入</span></span><br><span class="line">	curbytes = hexBytes</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自定义hash</span></span><br><span class="line">	myhash := sha256.New2()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; times; i++ &#123;</span><br><span class="line">		myhash.Reset()</span><br><span class="line">		myhash.Write2(curbytes)</span><br><span class="line">		myhash.Sum2(hashBytes[:<span class="number">0</span>]) <span class="comment">// 将结果写入预分配的字节切片</span></span><br><span class="line">		<span class="comment">// 将哈希值转为十六进制字符串</span></span><br><span class="line">		<span class="comment">//hex.Encode(hexBytes, hashBytes)</span></span><br><span class="line">		hex.EncodeAVX(&amp;hexBytes[<span class="number">0</span>], &amp;hashBytes[<span class="number">0</span>], <span class="number">32</span>, &amp;hex.Lower[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将十六进制字符串的字节切片作为下次计算的输入</span></span><br><span class="line">		curbytes = hexBytes</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(curbytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这里逐行讲解<strong>自定义hash</strong>的代码部分</p>
<p>首先是<code>myhash.Reset()</code>，这个代码和标准库一致，大家可以自行查看，因为每一次哈希计算前都必须重置h值。</p>
<p><code>myhash.Write2()</code>代码也很简单，直接走到了block，进入汇编层，使用了标准库的实现，注意我传的值64，因为第一个block必定为512字节，只所以用标准库，是因为第一个block的计算没有优化空间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myhash.Write2()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *digest)</span></span> Write2(p []<span class="type">byte</span>) &#123;</span><br><span class="line">	block(d, p[:<span class="number">64</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意调用完Write2后，digest结构的h值就已经发生了改变，作为下一个block的计算的h值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myhash.Sum2()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *digest)</span></span> Sum2(in []<span class="type">byte</span>) []<span class="type">byte</span> &#123;</span><br><span class="line">	hash := d.checkSum2()</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">append</span>(in, hash[:]...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *digest)</span></span> checkSum2() [Size]<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="comment">// padlen := abc</span></span><br><span class="line">	d.Write3(abc)</span><br><span class="line">	<span class="comment">// 汇编已经做了大小端转换</span></span><br><span class="line">	<span class="keyword">var</span> digest [Size]<span class="type">byte</span> = *(*[Size]<span class="type">byte</span>)(unsafe.Pointer(&amp;d.h[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// binary.BigEndian.PutUint32(digest[0:], d.h[0])</span></span><br><span class="line">	<span class="comment">// binary.BigEndian.PutUint32(digest[4:], d.h[1])</span></span><br><span class="line">	<span class="comment">// binary.BigEndian.PutUint32(digest[8:], d.h[2])</span></span><br><span class="line">	<span class="comment">// binary.BigEndian.PutUint32(digest[12:], d.h[3])</span></span><br><span class="line">	<span class="comment">// binary.BigEndian.PutUint32(digest[16:], d.h[4])</span></span><br><span class="line">	<span class="comment">// binary.BigEndian.PutUint32(digest[20:], d.h[5])</span></span><br><span class="line">	<span class="comment">// binary.BigEndian.PutUint32(digest[24:], d.h[6])</span></span><br><span class="line">	<span class="comment">// if !d.is224 &#123;</span></span><br><span class="line">	<span class="comment">// 	binary.BigEndian.PutUint32(digest[28:], d.h[7])</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="keyword">return</span> digest</span><br><span class="line">	<span class="comment">// a := *(*[32]byte)(unsafe.Pointer(&amp;d.h))</span></span><br><span class="line">	<span class="comment">// return a</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入恒为abc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *digest)</span></span> Write3(p []<span class="type">byte</span>) &#123;</span><br><span class="line">	block2(d, p[:<span class="number">64</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分代码有几个关注点：</p>
<ol>
<li>checkSum2调用的write3，write3走的block2，block2是标准库没有的，我自己高度优化的汇编代码（本质就是预计算w+k）</li>
<li>checkSum2注释了一大段的大小端转换，注释代码实际上是标准库的，我发现了这部分代码性能不好，首先循环每一次计算都要进行整整8次大小端32位int转换，每次转换又有4次位操作，相当于总的操作次数相当多。因此我直接在block2的汇编中用avx指令集直接做了256位的大小端转换，最终在高级语言中用unsafe返回，节省了很多时间。</li>
</ol>
<blockquote>
<p>汇编部分后面会提到</p>
</blockquote>
<h4 id="汇编部分"><a href="#汇编部分" class="headerlink" title="汇编部分"></a>汇编部分</h4><p>先谈大小端转换，汇编代码很简单，在h返回时，直接用avx指令转换一下，再MOV回去即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 直接把小端转大端返回，后面就不用uintput32了</span><br><span class="line">VMOVDQU (0*32)(CTX), XTMP0</span><br><span class="line">VMOVDQU flip_mask&lt;&gt;(SB), BYTE_FLIP_MASK</span><br><span class="line"></span><br><span class="line">// Apply Byte Flip Mask: LE -&gt; BE</span><br><span class="line">VPSHUFB BYTE_FLIP_MASK, XTMP0, XTMP0</span><br><span class="line">VMOVDQU XTMP0, (0*32)(CTX)</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">JB   done_hash</span><br></pre></td></tr></table></figure>

<p>再说汇编代码的剪枝，先给出未剪枝的代码过程（标准库，只贴了耗时长的核心计算过程）。标准库直接用了流水线的方法将w和h同时递进计算，效率非常高</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">avx2_loop1: <span class="comment">// for w0 - w47</span></span><br><span class="line">	<span class="comment">// Do 4 rounds and scheduling</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 将byte[0-15]组成的16字节 + [K0-K4]组成的16字节，存到栈的指定位置</span></span><br><span class="line">    <span class="comment">// 其实就是一次做了4个计算，即w0 + k0， w1 + k1， w2 + k2, w3 + k3，因为byte[0-3]就是对应w[0]</span></span><br><span class="line">    <span class="comment">// XDWORD0 对应 byte[0 - 15]</span></span><br><span class="line">	VPADDD  <span class="number">0</span>*<span class="number">32</span>(TBL)(SRND*<span class="number">1</span>), XDWORD0, XFER</span><br><span class="line">	VMOVDQU XFER, (_XFER + <span class="number">0</span>*<span class="number">32</span>)(SP)(SRND*<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	ROUND_AND_SCHED_N_0(_XFER + <span class="number">0</span>*<span class="number">32</span>, a, b, c, d, e, f, g, h, XDWORD0, XDWORD1, XDWORD2, XDWORD3)</span><br><span class="line">	ROUND_AND_SCHED_N_1(_XFER + <span class="number">0</span>*<span class="number">32</span>, h, a, b, c, d, e, f, g, XDWORD0, XDWORD1, XDWORD2, XDWORD3)</span><br><span class="line">	ROUND_AND_SCHED_N_2(_XFER + <span class="number">0</span>*<span class="number">32</span>, g, h, a, b, c, d, e, f, XDWORD0, XDWORD1, XDWORD2, XDWORD3)</span><br><span class="line">	ROUND_AND_SCHED_N_3(_XFER + <span class="number">0</span>*<span class="number">32</span>, f, g, h, a, b, c, d, e, XDWORD0, XDWORD1, XDWORD2, XDWORD3)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do 4 rounds and scheduling</span></span><br><span class="line">	VPADDD  <span class="number">1</span>*<span class="number">32</span>(TBL)(SRND*<span class="number">1</span>), XDWORD1, XFER</span><br><span class="line">	VMOVDQU XFER, (_XFER + <span class="number">1</span>*<span class="number">32</span>)(SP)(SRND*<span class="number">1</span>)</span><br><span class="line">	ROUND_AND_SCHED_N_0(_XFER + <span class="number">1</span>*<span class="number">32</span>, e, f, g, h, a, b, c, d, XDWORD1, XDWORD2, XDWORD3, XDWORD0)</span><br><span class="line">	ROUND_AND_SCHED_N_1(_XFER + <span class="number">1</span>*<span class="number">32</span>, d, e, f, g, h, a, b, c, XDWORD1, XDWORD2, XDWORD3, XDWORD0)</span><br><span class="line">	ROUND_AND_SCHED_N_2(_XFER + <span class="number">1</span>*<span class="number">32</span>, c, d, e, f, g, h, a, b, XDWORD1, XDWORD2, XDWORD3, XDWORD0)</span><br><span class="line">	ROUND_AND_SCHED_N_3(_XFER + <span class="number">1</span>*<span class="number">32</span>, b, c, d, e, f, g, h, a, XDWORD1, XDWORD2, XDWORD3, XDWORD0)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do 4 rounds and scheduling</span></span><br><span class="line">	VPADDD  <span class="number">2</span>*<span class="number">32</span>(TBL)(SRND*<span class="number">1</span>), XDWORD2, XFER</span><br><span class="line">	VMOVDQU XFER, (_XFER + <span class="number">2</span>*<span class="number">32</span>)(SP)(SRND*<span class="number">1</span>)</span><br><span class="line">	ROUND_AND_SCHED_N_0(_XFER + <span class="number">2</span>*<span class="number">32</span>, a, b, c, d, e, f, g, h, XDWORD2, XDWORD3, XDWORD0, XDWORD1)</span><br><span class="line">	ROUND_AND_SCHED_N_1(_XFER + <span class="number">2</span>*<span class="number">32</span>, h, a, b, c, d, e, f, g, XDWORD2, XDWORD3, XDWORD0, XDWORD1)</span><br><span class="line">	ROUND_AND_SCHED_N_2(_XFER + <span class="number">2</span>*<span class="number">32</span>, g, h, a, b, c, d, e, f, XDWORD2, XDWORD3, XDWORD0, XDWORD1)</span><br><span class="line">	ROUND_AND_SCHED_N_3(_XFER + <span class="number">2</span>*<span class="number">32</span>, f, g, h, a, b, c, d, e, XDWORD2, XDWORD3, XDWORD0, XDWORD1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do 4 rounds and scheduling</span></span><br><span class="line">	VPADDD  <span class="number">3</span>*<span class="number">32</span>(TBL)(SRND*<span class="number">1</span>), XDWORD3, XFER</span><br><span class="line">	VMOVDQU XFER, (_XFER + <span class="number">3</span>*<span class="number">32</span>)(SP)(SRND*<span class="number">1</span>)</span><br><span class="line">	ROUND_AND_SCHED_N_0(_XFER + <span class="number">3</span>*<span class="number">32</span>, e, f, g, h, a, b, c, d, XDWORD3, XDWORD0, XDWORD1, XDWORD2)</span><br><span class="line">	ROUND_AND_SCHED_N_1(_XFER + <span class="number">3</span>*<span class="number">32</span>, d, e, f, g, h, a, b, c, XDWORD3, XDWORD0, XDWORD1, XDWORD2)</span><br><span class="line">	ROUND_AND_SCHED_N_2(_XFER + <span class="number">3</span>*<span class="number">32</span>, c, d, e, f, g, h, a, b, XDWORD3, XDWORD0, XDWORD1, XDWORD2)</span><br><span class="line">	ROUND_AND_SCHED_N_3(_XFER + <span class="number">3</span>*<span class="number">32</span>, b, c, d, e, f, g, h, a, XDWORD3, XDWORD0, XDWORD1, XDWORD2)</span><br><span class="line"></span><br><span class="line">	ADDQ $<span class="number">4</span>*<span class="number">32</span>, SRND</span><br><span class="line">	CMPQ SRND, $<span class="number">3</span>*<span class="number">4</span>*<span class="number">32</span></span><br><span class="line">	JB   avx2_loop1</span><br><span class="line"></span><br><span class="line">avx2_loop2:</span><br><span class="line">	<span class="comment">// w48 - w63 processed with no scheduling (last 16 rounds)</span></span><br><span class="line">	VPADDD  <span class="number">0</span>*<span class="number">32</span>(TBL)(SRND*<span class="number">1</span>), XDWORD0, XFER</span><br><span class="line">	VMOVDQU XFER, (_XFER + <span class="number">0</span>*<span class="number">32</span>)(SP)(SRND*<span class="number">1</span>)</span><br><span class="line">	DO_ROUND_N_0(_XFER + <span class="number">0</span>*<span class="number">32</span>, a, b, c, d, e, f, g, h, h)</span><br><span class="line">	DO_ROUND_N_1(_XFER + <span class="number">0</span>*<span class="number">32</span>, h, a, b, c, d, e, f, g, h)</span><br><span class="line">	DO_ROUND_N_2(_XFER + <span class="number">0</span>*<span class="number">32</span>, g, h, a, b, c, d, e, f, g)</span><br><span class="line">	DO_ROUND_N_3(_XFER + <span class="number">0</span>*<span class="number">32</span>, f, g, h, a, b, c, d, e, f)</span><br><span class="line"></span><br><span class="line">	VPADDD  <span class="number">1</span>*<span class="number">32</span>(TBL)(SRND*<span class="number">1</span>), XDWORD1, XFER</span><br><span class="line">	VMOVDQU XFER, (_XFER + <span class="number">1</span>*<span class="number">32</span>)(SP)(SRND*<span class="number">1</span>)</span><br><span class="line">	DO_ROUND_N_0(_XFER + <span class="number">1</span>*<span class="number">32</span>, e, f, g, h, a, b, c, d, e)</span><br><span class="line">	DO_ROUND_N_1(_XFER + <span class="number">1</span>*<span class="number">32</span>, d, e, f, g, h, a, b, c, d)</span><br><span class="line">	DO_ROUND_N_2(_XFER + <span class="number">1</span>*<span class="number">32</span>, c, d, e, f, g, h, a, b, c)</span><br><span class="line">	DO_ROUND_N_3(_XFER + <span class="number">1</span>*<span class="number">32</span>, b, c, d, e, f, g, h, a, b)</span><br><span class="line"></span><br><span class="line">	ADDQ $<span class="number">2</span>*<span class="number">32</span>, SRND</span><br><span class="line"></span><br><span class="line">	VMOVDQU XDWORD2, XDWORD0</span><br><span class="line">	VMOVDQU XDWORD3, XDWORD1</span><br><span class="line"></span><br><span class="line">	CMPQ SRND, $<span class="number">4</span>*<span class="number">4</span>*<span class="number">32</span></span><br><span class="line">	JB   avx2_loop2</span><br><span class="line"></span><br><span class="line">	MOVQ dig+<span class="number">0</span>(FP), CTX <span class="comment">// d.h[8]</span></span><br><span class="line">	MOVQ _INP(SP), INP</span><br><span class="line"></span><br><span class="line">	addm(  <span class="number">0</span>(CTX), a)</span><br><span class="line">	addm(  <span class="number">4</span>(CTX), b)</span><br><span class="line">	addm(  <span class="number">8</span>(CTX), c)</span><br><span class="line">	addm( <span class="number">12</span>(CTX), d)</span><br><span class="line">	addm( <span class="number">16</span>(CTX), e)</span><br><span class="line">	addm( <span class="number">20</span>(CTX), f)</span><br><span class="line">	addm( <span class="number">24</span>(CTX), g)</span><br><span class="line">	addm( <span class="number">28</span>(CTX), h)</span><br><span class="line"></span><br><span class="line">	CMPQ _INP_END(SP), INP</span><br><span class="line">	JB   done_hash</span><br></pre></td></tr></table></figure>

<p>其代码，在每一次迭代计算h的过程中，往前计算w，因此我需要做的是不要计算w，并且在合适的地方用常量代替w+k</p>
<p>以下是我修改后的汇编</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">avx2_loop1: <span class="comment">// for w0 - w47</span></span><br><span class="line">	<span class="comment">// Do 4 rounds and scheduling</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// VMOVDQU 0*32(TBL)(SRND*1), XFER        </span></span><br><span class="line">	<span class="comment">// VMOVDQU XFER, (_XFER + 0*32)(SP)(SRND*1) </span></span><br><span class="line"></span><br><span class="line">	ROUND_AND_SCHED_N_0(_XFER + <span class="number">0</span>*<span class="number">32</span>, a, b, c, d, e, f, g, h)</span><br><span class="line">	ROUND_AND_SCHED_N_1(_XFER + <span class="number">0</span>*<span class="number">32</span>, h, a, b, c, d, e, f, g)</span><br><span class="line">	ROUND_AND_SCHED_N_2(_XFER + <span class="number">0</span>*<span class="number">32</span>, g, h, a, b, c, d, e, f)</span><br><span class="line">	ROUND_AND_SCHED_N_3(_XFER + <span class="number">0</span>*<span class="number">32</span>, f, g, h, a, b, c, d, e)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do 4 rounds and scheduling</span></span><br><span class="line">	<span class="comment">// VMOVDQU  1*32(TBL)(SRND*1), XFER</span></span><br><span class="line">	<span class="comment">// VMOVDQU XFER, (_XFER + 1*32)(SP)(SRND*1)</span></span><br><span class="line">	ROUND_AND_SCHED_N_0(_XFER + <span class="number">1</span>*<span class="number">32</span>, e, f, g, h, a, b, c, d)</span><br><span class="line">	ROUND_AND_SCHED_N_1(_XFER + <span class="number">1</span>*<span class="number">32</span>, d, e, f, g, h, a, b, c)</span><br><span class="line">	ROUND_AND_SCHED_N_2(_XFER + <span class="number">1</span>*<span class="number">32</span>, c, d, e, f, g, h, a, b)</span><br><span class="line">	ROUND_AND_SCHED_N_3(_XFER + <span class="number">1</span>*<span class="number">32</span>, b, c, d, e, f, g, h, a)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do 4 rounds and scheduling</span></span><br><span class="line">	<span class="comment">// VMOVDQU  2*32(TBL)(SRND*1), XFER</span></span><br><span class="line">	<span class="comment">// VMOVDQU XFER, (_XFER + 2*32)(SP)(SRND*1)</span></span><br><span class="line">	ROUND_AND_SCHED_N_0(_XFER + <span class="number">2</span>*<span class="number">32</span>, a, b, c, d, e, f, g, h)</span><br><span class="line">	ROUND_AND_SCHED_N_1(_XFER + <span class="number">2</span>*<span class="number">32</span>, h, a, b, c, d, e, f, g)</span><br><span class="line">	ROUND_AND_SCHED_N_2(_XFER + <span class="number">2</span>*<span class="number">32</span>, g, h, a, b, c, d, e, f)</span><br><span class="line">	ROUND_AND_SCHED_N_3(_XFER + <span class="number">2</span>*<span class="number">32</span>, f, g, h, a, b, c, d, e)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do 4 rounds and scheduling</span></span><br><span class="line">	<span class="comment">// VMOVDQU  3*32(TBL)(SRND*1), XFER</span></span><br><span class="line">	<span class="comment">// VMOVDQU XFER, (_XFER + 3*32)(SP)(SRND*1)</span></span><br><span class="line">	ROUND_AND_SCHED_N_0(_XFER + <span class="number">3</span>*<span class="number">32</span>, e, f, g, h, a, b, c, d)</span><br><span class="line">	ROUND_AND_SCHED_N_1(_XFER + <span class="number">3</span>*<span class="number">32</span>, d, e, f, g, h, a, b, c)</span><br><span class="line">	ROUND_AND_SCHED_N_2(_XFER + <span class="number">3</span>*<span class="number">32</span>, c, d, e, f, g, h, a, b)</span><br><span class="line">	ROUND_AND_SCHED_N_3(_XFER + <span class="number">3</span>*<span class="number">32</span>, b, c, d, e, f, g, h, a)</span><br><span class="line"></span><br><span class="line">	ADDQ $<span class="number">4</span>*<span class="number">32</span>, SRND</span><br><span class="line">	CMPQ SRND, $<span class="number">3</span>*<span class="number">4</span>*<span class="number">32</span></span><br><span class="line">	JB   avx2_loop1</span><br><span class="line"></span><br><span class="line">avx2_loop2:</span><br><span class="line"></span><br><span class="line">	<span class="comment">// VXORPS XDWORD0, XDWORD0, XDWORD0</span></span><br><span class="line">	<span class="comment">// VXORPS XDWORD1, XDWORD1, XDWORD1</span></span><br><span class="line">	<span class="comment">// VXORPS XDWORD2, XDWORD2, XDWORD2</span></span><br><span class="line">	<span class="comment">// VXORPS XDWORD3, XDWORD3, XDWORD3</span></span><br><span class="line">	<span class="comment">// w48 - w63 processed with no scheduling (last 16 rounds)</span></span><br><span class="line">	<span class="comment">// VMOVDQU 0*32(TBL)(SRND*1), XFER        </span></span><br><span class="line">	<span class="comment">// VMOVDQU XFER, (_XFER + 0*32)(SP)(SRND*1) </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// VPADDD  0*32(TBL)(SRND*1), XDWORD0, XFER</span></span><br><span class="line">	<span class="comment">// VMOVDQU XFER, (_XFER + 0*32)(SP)(SRND*1)</span></span><br><span class="line">	DO_ROUND_N_0(_XFER + <span class="number">0</span>*<span class="number">32</span>, a, b, c, d, e, f, g, h, h)</span><br><span class="line">	DO_ROUND_N_1(_XFER + <span class="number">0</span>*<span class="number">32</span>, h, a, b, c, d, e, f, g, h)</span><br><span class="line">	DO_ROUND_N_2(_XFER + <span class="number">0</span>*<span class="number">32</span>, g, h, a, b, c, d, e, f, g)</span><br><span class="line">	DO_ROUND_N_3(_XFER + <span class="number">0</span>*<span class="number">32</span>, f, g, h, a, b, c, d, e, f)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// VMOVDQU 1*32(TBL)(SRND*1), XFER        </span></span><br><span class="line">	<span class="comment">// VMOVDQU XFER, (_XFER + 1*32)(SP)(SRND*1) </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// VPADDD  1*32(TBL)(SRND*1), XDWORD1, XFER</span></span><br><span class="line">	<span class="comment">// VMOVDQU XFER, (_XFER + 1*32)(SP)(SRND*1)</span></span><br><span class="line">	DO_ROUND_N_0(_XFER + <span class="number">1</span>*<span class="number">32</span>, e, f, g, h, a, b, c, d, e)</span><br><span class="line">	DO_ROUND_N_1(_XFER + <span class="number">1</span>*<span class="number">32</span>, d, e, f, g, h, a, b, c, d)</span><br><span class="line">	DO_ROUND_N_2(_XFER + <span class="number">1</span>*<span class="number">32</span>, c, d, e, f, g, h, a, b, c)</span><br><span class="line">	DO_ROUND_N_3(_XFER + <span class="number">1</span>*<span class="number">32</span>, b, c, d, e, f, g, h, a, b)</span><br><span class="line"></span><br><span class="line">	ADDQ $<span class="number">2</span>*<span class="number">32</span>, SRND</span><br><span class="line"></span><br><span class="line">	<span class="comment">// VMOVDQU XDWORD2, XDWORD0</span></span><br><span class="line">	<span class="comment">// VMOVDQU XDWORD3, XDWORD1</span></span><br><span class="line">	<span class="comment">// 循环两次就退出</span></span><br><span class="line">	CMPQ SRND, $<span class="number">4</span>*<span class="number">4</span>*<span class="number">32</span></span><br><span class="line">	JB   avx2_loop2</span><br><span class="line"></span><br><span class="line">	MOVQ dig+<span class="number">0</span>(FP), CTX <span class="comment">// d.h[8]</span></span><br><span class="line">	MOVQ _INP(SP), INP</span><br><span class="line"></span><br><span class="line">	addm(  <span class="number">0</span>(CTX), a)</span><br><span class="line">	addm(  <span class="number">4</span>(CTX), b)</span><br><span class="line">	addm(  <span class="number">8</span>(CTX), c)</span><br><span class="line">	addm( <span class="number">12</span>(CTX), d)</span><br><span class="line">	addm( <span class="number">16</span>(CTX), e)</span><br><span class="line">	addm( <span class="number">20</span>(CTX), f)</span><br><span class="line">	addm( <span class="number">24</span>(CTX), g)</span><br><span class="line">	addm( <span class="number">28</span>(CTX), h)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 直接把小端转大端返回，后面就不用uintput32了</span></span><br><span class="line">	VMOVDQU (<span class="number">0</span>*<span class="number">32</span>)(CTX), XTMP0</span><br><span class="line">	VMOVDQU flip_mask&lt;&gt;(SB), BYTE_FLIP_MASK</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Apply Byte Flip Mask: LE -&gt; BE</span></span><br><span class="line">	VPSHUFB BYTE_FLIP_MASK, XTMP0, XTMP0</span><br><span class="line">	VMOVDQU XTMP0, (<span class="number">0</span>*<span class="number">32</span>)(CTX)</span><br><span class="line"></span><br><span class="line">	CMPQ _INP_END(SP), INP</span><br><span class="line">	JB   done_hash</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到节省了数据传输指令，也节省了<code>XTMP0 - XTMP3</code>的计算(实际就是w+k)。</p>
<p>我将TBL寄存器从标准库对应的k值，改成了我的k+w</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">avx2_do_last_block:</span><br><span class="line">	MOVQ $KW&lt;&gt;(SB), TBL</span><br><span class="line"></span><br><span class="line">	JMP avx2_last_block_enter</span><br></pre></td></tr></table></figure>

<p>总的优化就是这些，当然汇编代码很多细节在里面，这里就不赘述了，想了解的话可以直接去代码仓库里看看。</p>
<h4 id="代码替换"><a href="#代码替换" class="headerlink" title="代码替换"></a>代码替换</h4><p>也讲讲怎么替换标准库吧，因为默认情况下标准库是不可以写的。我的做法是用root权限，将标准库的对应sha256的<code>package sha256</code>文件夹全删了，然后把我改过的文件夹copy过去，再编译。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/15/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/17/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Corgis</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
